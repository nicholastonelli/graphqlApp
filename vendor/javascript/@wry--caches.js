// @wry/caches@1.0.1 downloaded from https://ga.jspm.io/npm:@wry/caches@1.0.1/lib/index.js

function defaultDispose$1(){}class StrongCache{constructor(e=Infinity,t=defaultDispose$1){this.max=e;this.dispose=t;this.map=new Map;this.newest=null;this.oldest=null}has(e){return this.map.has(e)}get(e){const t=this.getNode(e);return t&&t.value}get size(){return this.map.size}getNode(e){const t=this.map.get(e);if(t&&t!==this.newest){const{older:e,newer:s}=t;s&&(s.older=e);e&&(e.newer=s);t.older=this.newest;t.older.newer=t;t.newer=null;this.newest=t;t===this.oldest&&(this.oldest=s)}return t}set(e,t){let s=this.getNode(e);if(s)return s.value=t;s={key:e,value:t,newer:null,older:this.newest};this.newest&&(this.newest.newer=s);this.newest=s;this.oldest=this.oldest||s;this.map.set(e,s);return s.value}clean(){while(this.oldest&&this.map.size>this.max)this.delete(this.oldest.key)}delete(e){const t=this.map.get(e);if(t){t===this.newest&&(this.newest=t.older);t===this.oldest&&(this.oldest=t.newer);t.newer&&(t.newer.older=t.older);t.older&&(t.older.newer=t.newer);this.map.delete(e);this.dispose(t.value,e);return true}return false}}function noop(){}const e=noop;const t=typeof WeakRef!=="undefined"?WeakRef:function(e){return{deref:()=>e}};const s=typeof WeakMap!=="undefined"?WeakMap:Map;const i=typeof FinalizationRegistry!=="undefined"?FinalizationRegistry:function(){return{register:noop,unregister:noop}};const n=10024;class WeakCache{constructor(l=Infinity,o=e){this.max=l;this.dispose=o;this.map=new s;this.newest=null;this.oldest=null;this.unfinalizedNodes=new Set;this.finalizationScheduled=false;this.size=0;this.finalize=()=>{const e=this.unfinalizedNodes.values();for(let s=0;s<n;s++){const s=e.next().value;if(!s)break;this.unfinalizedNodes.delete(s);const i=s.key;delete s.key;s.keyRef=new t(i);this.registry.register(i,s,s)}this.unfinalizedNodes.size>0?queueMicrotask(this.finalize):this.finalizationScheduled=false};this.registry=new i(this.deleteNode.bind(this))}has(e){return this.map.has(e)}get(e){const t=this.getNode(e);return t&&t.value}getNode(e){const t=this.map.get(e);if(t&&t!==this.newest){const{older:e,newer:s}=t;s&&(s.older=e);e&&(e.newer=s);t.older=this.newest;t.older.newer=t;t.newer=null;this.newest=t;t===this.oldest&&(this.oldest=s)}return t}set(e,t){let s=this.getNode(e);if(s)return s.value=t;s={key:e,value:t,newer:null,older:this.newest};this.newest&&(this.newest.newer=s);this.newest=s;this.oldest=this.oldest||s;this.scheduleFinalization(s);this.map.set(e,s);this.size++;return s.value}clean(){while(this.oldest&&this.size>this.max)this.deleteNode(this.oldest)}deleteNode(e){e===this.newest&&(this.newest=e.older);e===this.oldest&&(this.oldest=e.newer);e.newer&&(e.newer.older=e.older);e.older&&(e.older.newer=e.newer);this.size--;const t=e.key||e.keyRef&&e.keyRef.deref();this.dispose(e.value,t);e.keyRef?this.registry.unregister(e):this.unfinalizedNodes.delete(e);t&&this.map.delete(t)}delete(e){const t=this.map.get(e);if(t){this.deleteNode(t);return true}return false}scheduleFinalization(e){this.unfinalizedNodes.add(e);if(!this.finalizationScheduled){this.finalizationScheduled=true;queueMicrotask(this.finalize)}}}export{StrongCache,WeakCache};

