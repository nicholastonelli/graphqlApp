// lru-cache@10.4.3 downloaded from https://ga.jspm.io/npm:lru-cache@10.4.3/dist/commonjs/index.js

import t from"process";var e={};var i=t;Object.defineProperty(e,"__esModule",{value:true});e.LRUCache=void 0;const s=typeof performance==="object"&&performance&&typeof performance.now==="function"?performance:Date;const o=new Set;const h=typeof i!=="object"||!i?{}:i;const emitWarning=(t,e,i,s)=>{typeof h.emitWarning==="function"?h.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)};let n=globalThis.AbortController;let a=globalThis.AbortSignal;if(typeof n==="undefined"){a=class AbortSignal{onabort;_onabort=[];reason;aborted=false;addEventListener(t,e){this._onabort.push(e)}};n=class AbortController{constructor(){warnACPolyfill()}signal=new a;abort(t){if(!this.signal.aborted){this.signal.reason=t;this.signal.aborted=true;for(const e of this.signal._onabort)e(t);this.signal.onabort?.(t)}}};let t=h.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1";const warnACPolyfill=()=>{if(t){t=false;emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",warnACPolyfill)}}}const shouldWarn=t=>!o.has(t);Symbol("type");const isPosInt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t);const getUintArray=t=>isPosInt(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?ZeroArray:null:null;class ZeroArray extends Array{constructor(t){super(t);this.fill(0)}}class Stack{heap;length;static#t=false;static create(t){const e=getUintArray(t);if(!e)return[];Stack.#t=true;const i=new Stack(t,e);Stack.#t=false;return i}constructor(t,e){if(!Stack.#t)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t);this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class LRUCache{#e;#i;#s;#o;#h;#n;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#a;#r;#l;#c;#d;#u;#f;#p;#g;#v;#S;#m;#y;#w;#z;#L;#A;static unsafeExposeInternals(t){return{starts:t.#y,ttls:t.#w,sizes:t.#m,keyMap:t.#l,keyList:t.#c,valList:t.#d,next:t.#u,prev:t.#f,get head(){return t.#p},get tail(){return t.#g},free:t.#v,isBackgroundFetch:e=>t.#F(e),backgroundFetch:(e,i,s,o)=>t.#k(e,i,s,o),moveToTail:e=>t.#x(e),indexes:e=>t.#_(e),rindexes:e=>t.#T(e),isStale:e=>t.#b(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#r}get size(){return this.#a}get fetchMethod(){return this.#h}get memoMethod(){return this.#n}get dispose(){return this.#s}get disposeAfter(){return this.#o}constructor(t){const{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:h,updateAgeOnGet:n,updateAgeOnHas:a,allowStale:r,dispose:l,disposeAfter:c,noDisposeOnSet:d,noUpdateTTL:u,maxSize:f=0,maxEntrySize:p=0,sizeCalculation:g,fetchMethod:v,memoMethod:S,noDeleteOnFetchRejection:m,noDeleteOnStaleGet:y,allowStaleOnFetchRejection:w,allowStaleOnFetchAbort:z,ignoreFetchAbort:L}=t;if(e!==0&&!isPosInt(e))throw new TypeError("max option must be a nonnegative integer");const A=e?getUintArray(e):Array;if(!A)throw new Error("invalid max value: "+e);this.#e=e;this.#i=f;this.maxEntrySize=p||this.#i;this.sizeCalculation=g;if(this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!=="function")throw new TypeError("sizeCalculation set to non-function")}if(S!==void 0&&typeof S!=="function")throw new TypeError("memoMethod must be a function if defined");this.#n=S;if(v!==void 0&&typeof v!=="function")throw new TypeError("fetchMethod must be a function if specified");this.#h=v;this.#L=!!v;this.#l=new Map;this.#c=new Array(e).fill(void 0);this.#d=new Array(e).fill(void 0);this.#u=new A(e);this.#f=new A(e);this.#p=0;this.#g=0;this.#v=Stack.create(e);this.#a=0;this.#r=0;typeof l==="function"&&(this.#s=l);if(typeof c==="function"){this.#o=c;this.#S=[]}else{this.#o=void 0;this.#S=void 0}this.#z=!!this.#s;this.#A=!!this.#o;this.noDisposeOnSet=!!d;this.noUpdateTTL=!!u;this.noDeleteOnFetchRejection=!!m;this.allowStaleOnFetchRejection=!!w;this.allowStaleOnFetchAbort=!!z;this.ignoreFetchAbort=!!L;if(this.maxEntrySize!==0){if(this.#i!==0&&!isPosInt(this.#i))throw new TypeError("maxSize must be a positive integer if specified");if(!isPosInt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#O()}this.allowStale=!!r;this.noDeleteOnStaleGet=!!y;this.updateAgeOnGet=!!n;this.updateAgeOnHas=!!a;this.ttlResolution=isPosInt(s)||s===0?s:1;this.ttlAutopurge=!!h;this.ttl=i||0;if(this.ttl){if(!isPosInt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#E()}if(this.#e===0&&this.ttl===0&&this.#i===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";if(shouldWarn(t)){o.add(t);const e="TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";emitWarning(e,"UnboundedCacheWarning",t,LRUCache)}}}getRemainingTTL(t){return this.#l.has(t)?Infinity:0}#E(){const t=new ZeroArray(this.#e);const e=new ZeroArray(this.#e);this.#w=t;this.#y=e;this.#D=(i,o,h=s.now())=>{e[i]=o!==0?h:0;t[i]=o;if(o!==0&&this.ttlAutopurge){const t=setTimeout((()=>{this.#b(i)&&this.#M(this.#c[i],"expire")}),o+1);t.unref&&t.unref()}};this.#C=i=>{e[i]=t[i]!==0?s.now():0};this.#R=(s,o)=>{if(t[o]){const h=t[o];const n=e[o];if(!h||!n)return;s.ttl=h;s.start=n;s.now=i||getNow();const a=s.now-n;s.remainingTTL=h-a}};let i=0;const getNow=()=>{const t=s.now();if(this.ttlResolution>0){i=t;const e=setTimeout((()=>i=0),this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=s=>{const o=this.#l.get(s);if(o===void 0)return 0;const h=t[o];const n=e[o];if(!h||!n)return Infinity;const a=(i||getNow())-n;return h-a};this.#b=s=>{const o=e[s];const h=t[s];return!!h&&!!o&&(i||getNow())-o>h}}#C=()=>{};#R=()=>{};#D=()=>{};#b=()=>false;#O(){const t=new ZeroArray(this.#e);this.#r=0;this.#m=t;this.#W=e=>{this.#r-=t[e];t[e]=0};this.#I=(t,e,i,s)=>{if(this.#F(e))return 0;if(!isPosInt(i)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if(typeof s!=="function")throw new TypeError("sizeCalculation must be a function");i=s(e,t);if(!isPosInt(i))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return i};this.#B=(e,i,s)=>{t[e]=i;if(this.#i){const i=this.#i-t[e];while(this.#r>i)this.#U(true)}this.#r+=t[e];if(s){s.entrySize=i;s.totalCalculatedSize=this.#r}}}#W=t=>{};#B=(t,e,i)=>{};#I=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#_({allowStale:t=this.allowStale}={}){if(this.#a)for(let e=this.#g;true;){if(!this.#G(e))break;!t&&this.#b(e)||(yield e);if(e===this.#p)break;e=this.#f[e]}}*#T({allowStale:t=this.allowStale}={}){if(this.#a)for(let e=this.#p;true;){if(!this.#G(e))break;!t&&this.#b(e)||(yield e);if(e===this.#g)break;e=this.#u[e]}}#G(t){return t!==void 0&&this.#l.get(this.#c[t])===t}*entries(){for(const t of this.#_())this.#d[t]===void 0||this.#c[t]===void 0||this.#F(this.#d[t])||(yield[this.#c[t],this.#d[t]])}*rentries(){for(const t of this.#T())this.#d[t]===void 0||this.#c[t]===void 0||this.#F(this.#d[t])||(yield[this.#c[t],this.#d[t]])}*keys(){for(const t of this.#_()){const e=this.#c[t];e===void 0||this.#F(this.#d[t])||(yield e)}}*rkeys(){for(const t of this.#T()){const e=this.#c[t];e===void 0||this.#F(this.#d[t])||(yield e)}}*values(){for(const t of this.#_()){const e=this.#d[t];e===void 0||this.#F(this.#d[t])||(yield this.#d[t])}}*rvalues(){for(const t of this.#T()){const e=this.#d[t];e===void 0||this.#F(this.#d[t])||(yield this.#d[t])}}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#_()){const s=this.#d[i];const o=this.#F(s)?s.__staleWhileFetching:s;if(o!==void 0&&t(o,this.#c[i],this))return this.get(this.#c[i],e)}}forEach(t,e=this){for(const i of this.#_()){const s=this.#d[i];const o=this.#F(s)?s.__staleWhileFetching:s;o!==void 0&&t.call(e,o,this.#c[i],this)}}rforEach(t,e=this){for(const i of this.#T()){const s=this.#d[i];const o=this.#F(s)?s.__staleWhileFetching:s;o!==void 0&&t.call(e,o,this.#c[i],this)}}purgeStale(){let t=false;for(const e of this.#T({allowStale:true}))if(this.#b(e)){this.#M(this.#c[e],"expire");t=true}return t}info(t){const e=this.#l.get(t);if(e===void 0)return;const i=this.#d[e];const o=this.#F(i)?i.__staleWhileFetching:i;if(o===void 0)return;const h={value:o};if(this.#w&&this.#y){const t=this.#w[e];const i=this.#y[e];if(t&&i){const e=t-(s.now()-i);h.ttl=e;h.start=Date.now()}}this.#m&&(h.size=this.#m[e]);return h}dump(){const t=[];for(const e of this.#_({allowStale:true})){const i=this.#c[e];const o=this.#d[e];const h=this.#F(o)?o.__staleWhileFetching:o;if(h===void 0||i===void 0)continue;const n={value:h};if(this.#w&&this.#y){n.ttl=this.#w[e];const t=s.now()-this.#y[e];n.start=Math.floor(Date.now()-t)}this.#m&&(n.size=this.#m[e]);t.unshift([i,n])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const t=Date.now()-i.start;i.start=s.now()-t}this.set(e,i.value,i)}}set(t,e,i={}){if(e===void 0){this.delete(t);return this}const{ttl:s=this.ttl,start:o,noDisposeOnSet:h=this.noDisposeOnSet,sizeCalculation:n=this.sizeCalculation,status:a}=i;let{noUpdateTTL:r=this.noUpdateTTL}=i;const l=this.#I(t,e,i.size||0,n);if(this.maxEntrySize&&l>this.maxEntrySize){if(a){a.set="miss";a.maxEntrySizeExceeded=true}this.#M(t,"set");return this}let c=this.#a===0?void 0:this.#l.get(t);if(c===void 0){c=this.#a===0?this.#g:this.#v.length!==0?this.#v.pop():this.#a===this.#e?this.#U(false):this.#a;this.#c[c]=t;this.#d[c]=e;this.#l.set(t,c);this.#u[this.#g]=c;this.#f[c]=this.#g;this.#g=c;this.#a++;this.#B(c,l,a);a&&(a.set="add");r=false}else{this.#x(c);const i=this.#d[c];if(e!==i){if(this.#L&&this.#F(i)){i.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:e}=i;if(e!==void 0&&!h){this.#z&&this.#s?.(e,t,"set");this.#A&&this.#S?.push([e,t,"set"])}}else if(!h){this.#z&&this.#s?.(i,t,"set");this.#A&&this.#S?.push([i,t,"set"])}this.#W(c);this.#B(c,l,a);this.#d[c]=e;if(a){a.set="replace";const t=i&&this.#F(i)?i.__staleWhileFetching:i;t!==void 0&&(a.oldValue=t)}}else a&&(a.set="update")}s===0||this.#w||this.#E();if(this.#w){r||this.#D(c,s,o);a&&this.#R(a,c)}if(!h&&this.#A&&this.#S){const t=this.#S;let e;while(e=t?.shift())this.#o?.(...e)}return this}pop(){try{while(this.#a){const t=this.#d[this.#p];this.#U(true);if(this.#F(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(t!==void 0)return t}}finally{if(this.#A&&this.#S){const t=this.#S;let e;while(e=t?.shift())this.#o?.(...e)}}}#U(t){const e=this.#p;const i=this.#c[e];const s=this.#d[e];if(this.#L&&this.#F(s))s.__abortController.abort(new Error("evicted"));else if(this.#z||this.#A){this.#z&&this.#s?.(s,i,"evict");this.#A&&this.#S?.push([s,i,"evict"])}this.#W(e);if(t){this.#c[e]=void 0;this.#d[e]=void 0;this.#v.push(e)}if(this.#a===1){this.#p=this.#g=0;this.#v.length=0}else this.#p=this.#u[e];this.#l.delete(i);this.#a--;return e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e;const o=this.#l.get(t);if(o!==void 0){const t=this.#d[o];if(this.#F(t)&&t.__staleWhileFetching===void 0)return false;if(!this.#b(o)){i&&this.#C(o);if(s){s.has="hit";this.#R(s,o)}return true}if(s){s.has="stale";this.#R(s,o)}}else s&&(s.has="miss");return false}peek(t,e={}){const{allowStale:i=this.allowStale}=e;const s=this.#l.get(t);if(s===void 0||!i&&this.#b(s))return;const o=this.#d[s];return this.#F(o)?o.__staleWhileFetching:o}#k(t,e,i,s){const o=e===void 0?void 0:this.#d[e];if(this.#F(o))return o;const h=new n;const{signal:a}=i;a?.addEventListener("abort",(()=>h.abort(a.reason)),{signal:h.signal});const r={signal:h.signal,options:i,context:s};const cb=(s,o=false)=>{const{aborted:n}=h.signal;const a=i.ignoreFetchAbort&&s!==void 0;if(i.status)if(n&&!o){i.status.fetchAborted=true;i.status.fetchError=h.signal.reason;a&&(i.status.fetchAbortIgnored=true)}else i.status.fetchResolved=true;if(n&&!a&&!o)return fetchFail(h.signal.reason);const c=l;if(this.#d[e]===l)if(s===void 0)c.__staleWhileFetching?this.#d[e]=c.__staleWhileFetching:this.#M(t,"fetch");else{i.status&&(i.status.fetchUpdated=true);this.set(t,s,r.options)}return s};const eb=t=>{if(i.status){i.status.fetchRejected=true;i.status.fetchError=t}return fetchFail(t)};const fetchFail=s=>{const{aborted:o}=h.signal;const n=o&&i.allowStaleOnFetchAbort;const a=n||i.allowStaleOnFetchRejection;const r=a||i.noDeleteOnFetchRejection;const c=l;if(this.#d[e]===l){const i=!r||c.__staleWhileFetching===void 0;i?this.#M(t,"fetch"):n||(this.#d[e]=c.__staleWhileFetching)}if(a){i.status&&c.__staleWhileFetching!==void 0&&(i.status.returnedStale=true);return c.__staleWhileFetching}if(c.__returned===c)throw s};const pcall=(e,s)=>{const n=this.#h?.(t,o,r);n&&n instanceof Promise&&n.then((t=>e(t===void 0?void 0:t)),s);h.signal.addEventListener("abort",(()=>{if(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort){e(void 0);i.allowStaleOnFetchAbort&&(e=t=>cb(t,true))}}))};i.status&&(i.status.fetchDispatched=true);const l=new Promise(pcall).then(cb,eb);const c=Object.assign(l,{__abortController:h,__staleWhileFetching:o,__returned:void 0});if(e===void 0){this.set(t,c,{...r.options,status:void 0});e=this.#l.get(t)}else this.#d[e]=c;return c}#F(t){if(!this.#L)return false;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof n}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:a=0,sizeCalculation:r=this.sizeCalculation,noUpdateTTL:l=this.noUpdateTTL,noDeleteOnFetchRejection:c=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:d=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=false,status:v,signal:S}=e;if(!this.#L){v&&(v.fetch="get");return this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:o,status:v})}const m={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:o,ttl:h,noDisposeOnSet:n,size:a,sizeCalculation:r,noUpdateTTL:l,noDeleteOnFetchRejection:c,allowStaleOnFetchRejection:d,allowStaleOnFetchAbort:f,ignoreFetchAbort:u,status:v,signal:S};let y=this.#l.get(t);if(y===void 0){v&&(v.fetch="miss");const e=this.#k(t,y,m,p);return e.__returned=e}{const e=this.#d[y];if(this.#F(e)){const t=i&&e.__staleWhileFetching!==void 0;if(v){v.fetch="inflight";t&&(v.returnedStale=true)}return t?e.__staleWhileFetching:e.__returned=e}const o=this.#b(y);if(!g&&!o){v&&(v.fetch="hit");this.#x(y);s&&this.#C(y);v&&this.#R(v,y);return e}const h=this.#k(t,y,m,p);const n=h.__staleWhileFetching!==void 0;const a=n&&i;if(v){v.fetch=o?"stale":"refresh";a&&o&&(v.returnedStale=true)}return a?h.__staleWhileFetching:h.__returned=h}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(i===void 0)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=this.#n;if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:o,...h}=e;const n=this.get(t,h);if(!o&&n!==void 0)return n;const a=i(t,n,{options:h,context:s});this.set(t,a,h);return a}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:o=this.noDeleteOnStaleGet,status:h}=e;const n=this.#l.get(t);if(n!==void 0){const e=this.#d[n];const a=this.#F(e);h&&this.#R(h,n);if(this.#b(n)){h&&(h.get="stale");if(a){h&&i&&e.__staleWhileFetching!==void 0&&(h.returnedStale=true);return i?e.__staleWhileFetching:void 0}o||this.#M(t,"expire");h&&i&&(h.returnedStale=true);return i?e:void 0}h&&(h.get="hit");if(a)return e.__staleWhileFetching;this.#x(n);s&&this.#C(n);return e}h&&(h.get="miss")}#j(t,e){this.#f[e]=t;this.#u[t]=e}#x(t){if(t!==this.#g){t===this.#p?this.#p=this.#u[t]:this.#j(this.#f[t],this.#u[t]);this.#j(this.#g,t);this.#g=t}}delete(t){return this.#M(t,"delete")}#M(t,e){let i=false;if(this.#a!==0){const s=this.#l.get(t);if(s!==void 0){i=true;if(this.#a===1)this.#N(e);else{this.#W(s);const i=this.#d[s];if(this.#F(i))i.__abortController.abort(new Error("deleted"));else if(this.#z||this.#A){this.#z&&this.#s?.(i,t,e);this.#A&&this.#S?.push([i,t,e])}this.#l.delete(t);this.#c[s]=void 0;this.#d[s]=void 0;if(s===this.#g)this.#g=this.#f[s];else if(s===this.#p)this.#p=this.#u[s];else{const t=this.#f[s];this.#u[t]=this.#u[s];const e=this.#u[s];this.#f[e]=this.#f[s]}this.#a--;this.#v.push(s)}}}if(this.#A&&this.#S?.length){const t=this.#S;let e;while(e=t?.shift())this.#o?.(...e)}return i}clear(){return this.#N("delete")}#N(t){for(const e of this.#T({allowStale:true})){const i=this.#d[e];if(this.#F(i))i.__abortController.abort(new Error("deleted"));else{const s=this.#c[e];this.#z&&this.#s?.(i,s,t);this.#A&&this.#S?.push([i,s,t])}}this.#l.clear();this.#d.fill(void 0);this.#c.fill(void 0);if(this.#w&&this.#y){this.#w.fill(0);this.#y.fill(0)}this.#m&&this.#m.fill(0);this.#p=0;this.#g=0;this.#v.length=0;this.#r=0;this.#a=0;if(this.#A&&this.#S){const t=this.#S;let e;while(e=t?.shift())this.#o?.(...e)}}}e.LRUCache=LRUCache;const r=e.__esModule;const l=e.LRUCache;export{l as LRUCache,r as __esModule,e as default};

