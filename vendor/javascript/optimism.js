// optimism@0.18.1 downloaded from https://ga.jspm.io/npm:optimism@0.18.1/lib/index.js

import{Trie as e}from"@wry/trie";export{Trie as KeyTrie}from"@wry/trie";import{StrongCache as t}from"@wry/caches";import{Slot as r}from"@wry/context";export{Slot,asyncFromGen,bind as bindContext,noContext,setTimeout}from"@wry/context";const n=new r;function nonReactive(e){return n.withValue(void 0,e)}const{hasOwnProperty:i}=Object.prototype;const s=Array.from||function(e){const t=[];e.forEach((e=>t.push(e)));return t};function maybeUnsubscribe(e){const{unsubscribe:t}=e;if(typeof t==="function"){e.unsubscribe=void 0;t()}}const l=[];const o=100;function assert(e,t){if(!e)throw new Error(t||"assertion failure")}function valueIs(e,t){const r=e.length;return r>0&&r===t.length&&e[r-1]===t[r-1]}function valueGet(e){switch(e.length){case 0:throw new Error("unknown value");case 1:return e[0];case 2:throw e[1]}}function valueCopy(e){return e.slice(0)}class Entry{constructor(e){this.fn=e;this.parents=new Set;this.childValues=new Map;this.dirtyChildren=null;this.dirty=true;this.recomputing=false;this.value=[];this.deps=null;++Entry.count}peek(){if(this.value.length===1&&!mightBeDirty(this)){rememberParent(this);return this.value[0]}}recompute(e){assert(!this.recomputing,"already recomputing");rememberParent(this);return mightBeDirty(this)?reallyRecompute(this,e):valueGet(this.value)}setDirty(){if(!this.dirty){this.dirty=true;reportDirty(this);maybeUnsubscribe(this)}}dispose(){this.setDirty();forgetChildren(this);eachParent(this,((e,t)=>{e.setDirty();forgetChild(e,this)}))}forget(){this.dispose()}dependOn(e){e.add(this);this.deps||(this.deps=l.pop()||new Set);this.deps.add(e)}forgetDeps(){if(this.deps){s(this.deps).forEach((e=>e.delete(this)));this.deps.clear();l.push(this.deps);this.deps=null}}}Entry.count=0;function rememberParent(e){const t=n.getValue();if(t){e.parents.add(t);t.childValues.has(e)||t.childValues.set(e,[]);mightBeDirty(e)?reportDirtyChild(t,e):reportCleanChild(t,e);return t}}function reallyRecompute(e,t){forgetChildren(e);n.withValue(e,recomputeNewValue,[e,t]);maybeSubscribe(e,t)&&setClean(e);return valueGet(e.value)}function recomputeNewValue(e,t){e.recomputing=true;const{normalizeResult:r}=e;let n;r&&e.value.length===1&&(n=valueCopy(e.value));e.value.length=0;try{e.value[0]=e.fn.apply(null,t);if(r&&n&&!valueIs(n,e.value))try{e.value[0]=r(e.value[0],n[0])}catch(e){}}catch(t){e.value[1]=t}e.recomputing=false}function mightBeDirty(e){return e.dirty||!!(e.dirtyChildren&&e.dirtyChildren.size)}function setClean(e){e.dirty=false;mightBeDirty(e)||reportClean(e)}function reportDirty(e){eachParent(e,reportDirtyChild)}function reportClean(e){eachParent(e,reportCleanChild)}function eachParent(e,t){const r=e.parents.size;if(r){const n=s(e.parents);for(let i=0;i<r;++i)t(n[i],e)}}function reportDirtyChild(e,t){assert(e.childValues.has(t));assert(mightBeDirty(t));const r=!mightBeDirty(e);if(e.dirtyChildren){if(e.dirtyChildren.has(t))return}else e.dirtyChildren=l.pop()||new Set;e.dirtyChildren.add(t);r&&reportDirty(e)}function reportCleanChild(e,t){assert(e.childValues.has(t));assert(!mightBeDirty(t));const r=e.childValues.get(t);r.length===0?e.childValues.set(t,valueCopy(t.value)):valueIs(r,t.value)||e.setDirty();removeDirtyChild(e,t);mightBeDirty(e)||reportClean(e)}function removeDirtyChild(e,t){const r=e.dirtyChildren;if(r){r.delete(t);if(r.size===0){l.length<o&&l.push(r);e.dirtyChildren=null}}}function forgetChildren(e){e.childValues.size>0&&e.childValues.forEach(((t,r)=>{forgetChild(e,r)}));e.forgetDeps();assert(e.dirtyChildren===null)}function forgetChild(e,t){t.parents.delete(e);e.childValues.delete(t);removeDirtyChild(e,t)}function maybeSubscribe(e,t){if(typeof e.subscribe==="function")try{maybeUnsubscribe(e);e.unsubscribe=e.subscribe.apply(null,t)}catch(t){e.setDirty();return false}return true}const u={setDirty:true,dispose:true,forget:true};function dep(e){const t=new Map;const r=e&&e.subscribe;function depend(e){const i=n.getValue();if(i){let n=t.get(e);n||t.set(e,n=new Set);i.dependOn(n);if(typeof r==="function"){maybeUnsubscribe(n);n.unsubscribe=r(e)}}}depend.dirty=function dirty(e,r){const n=t.get(e);if(n){const l=r&&i.call(u,r)?r:"setDirty";s(n).forEach((e=>e[l]()));t.delete(e);maybeUnsubscribe(n)}};return depend}let a;function defaultMakeCacheKey(...t){const r=a||(a=new e(typeof WeakMap==="function"));return r.lookupArray(t)}const c=new Set;function wrap(e,{max:r=Math.pow(2,16),keyArgs:i,makeCacheKey:s=defaultMakeCacheKey,normalizeResult:l,subscribe:o,cache:u=t}=Object.create(null)){const a=typeof u==="function"?new u(r,(e=>e.dispose())):u;const optimistic=function(){const t=s.apply(null,i?i.apply(null,arguments):arguments);if(t===void 0)return e.apply(null,arguments);let r=a.get(t);if(!r){a.set(t,r=new Entry(e));r.normalizeResult=l;r.subscribe=o;r.forget=()=>a.delete(t)}const u=r.recompute(Array.prototype.slice.call(arguments));a.set(t,r);c.add(a);if(!n.hasValue()){c.forEach((e=>e.clean()));c.clear()}return u};Object.defineProperty(optimistic,"size",{get:()=>a.size,configurable:false,enumerable:false});Object.freeze(optimistic.options={max:r,keyArgs:i,makeCacheKey:s,normalizeResult:l,subscribe:o,cache:a});function dirtyKey(e){const t=e&&a.get(e);t&&t.setDirty()}optimistic.dirtyKey=dirtyKey;optimistic.dirty=function dirty(){dirtyKey(s.apply(null,arguments))};function peekKey(e){const t=e&&a.get(e);if(t)return t.peek()}optimistic.peekKey=peekKey;optimistic.peek=function peek(){return peekKey(s.apply(null,arguments))};function forgetKey(e){return!!e&&a.delete(e)}optimistic.forgetKey=forgetKey;optimistic.forget=function forget(){return forgetKey(s.apply(null,arguments))};optimistic.makeCacheKey=s;optimistic.getKey=i?function getKey(){return s.apply(null,i.apply(null,arguments))}:s;return Object.freeze(optimistic)}export{defaultMakeCacheKey,dep,nonReactive,wrap};

