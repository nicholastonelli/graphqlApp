// minipass@7.1.2 downloaded from https://ga.jspm.io/npm:minipass@7.1.2/dist/commonjs/index.js

import*as t from"node:events";import*as e from"node:stream";import*as s from"node:string_decoder";import i from"process";import r from"buffer";var n=t;try{"default"in t&&(n=t.default)}catch(t){}var o=e;try{"default"in e&&(o=e.default)}catch(t){}var h=s;try{"default"in s&&(h=s.default)}catch(t){}var a={};var f=r.Buffer;var l=i;var u=a&&a.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(a,"__esModule",{value:true});a.Minipass=a.isWritable=a.isReadable=a.isStream=void 0;const c=typeof l==="object"&&l?l:{stdout:null,stderr:null};const d=n;const m=u(o);const p=h;const isStream=t=>!!t&&typeof t==="object"&&(t instanceof Minipass||t instanceof m.default||(0,a.isReadable)(t)||(0,a.isWritable)(t));a.isStream=isStream;const isReadable=t=>!!t&&typeof t==="object"&&t instanceof d.EventEmitter&&typeof t.pipe==="function"&&t.pipe!==m.default.Writable.prototype.pipe;a.isReadable=isReadable;const isWritable=t=>!!t&&typeof t==="object"&&t instanceof d.EventEmitter&&typeof t.write==="function"&&typeof t.end==="function";a.isWritable=isWritable;const b=Symbol("EOF");const y=Symbol("maybeEmitEnd");const g=Symbol("emittedEnd");const E=Symbol("emittingEnd");const S=Symbol("emittedError");const w=Symbol("closed");const v=Symbol("read");const j=Symbol("flush");const M=Symbol("flushChunk");const L=Symbol("encoding");const x=Symbol("decoder");const P=Symbol("flowing");const _=Symbol("paused");const A=Symbol("resume");const O=Symbol("buffer");const R=Symbol("pipes");const B=Symbol("bufferLength");const W=Symbol("bufferPush");const D=Symbol("bufferShift");const T=Symbol("objectMode");const C=Symbol("destroyed");const I=Symbol("error");const N=Symbol("emitData");const k=Symbol("emitEnd");const F=Symbol("emitEnd2");const V=Symbol("async");const Y=Symbol("abort");const q=Symbol("aborted");const z=Symbol("signal");const G=Symbol("dataListeners");const H=Symbol("discarded");const defer=t=>Promise.resolve().then(t);const nodefer=t=>t();const isEndish=t=>t==="end"||t==="finish"||t==="prefinish";const isArrayBufferLike=t=>t instanceof ArrayBuffer||!!t&&typeof t==="object"&&t.constructor&&t.constructor.name==="ArrayBuffer"&&t.byteLength>=0;const isArrayBufferView=t=>!f.isBuffer(t)&&ArrayBuffer.isView(t);class Pipe{src;dest;opts;ondrain;constructor(t,e,s){this.src=t;this.dest=e;this.opts=s;this.ondrain=()=>t[A]();this.dest.on("drain",this.ondrain)}unpipe(){this.dest.removeListener("drain",this.ondrain)}proxyErrors(t){}end(){this.unpipe();this.opts.end&&this.dest.end()}}class PipeProxyErrors extends Pipe{unpipe(){this.src.removeListener("error",this.proxyErrors);super.unpipe()}constructor(t,e,s){super(t,e,s);this.proxyErrors=t=>e.emit("error",t);t.on("error",this.proxyErrors)}}const isObjectModeOptions=t=>!!t.objectMode;const isEncodingOptions=t=>!t.objectMode&&!!t.encoding&&t.encoding!=="buffer";class Minipass extends d.EventEmitter{[P]=false;[_]=false;[R]=[];[O]=[];[T];[L];[V];[x];[b]=false;[g]=false;[E]=false;[w]=false;[S]=null;[B]=0;[C]=false;[z];[q]=false;[G]=0;[H]=false;writable=true;readable=true;constructor(...t){const e=t[0]||{};super();if(e.objectMode&&typeof e.encoding==="string")throw new TypeError("Encoding and objectMode may not be used together");if(isObjectModeOptions(e)){this[T]=true;this[L]=null}else if(isEncodingOptions(e)){this[L]=e.encoding;this[T]=false}else{this[T]=false;this[L]=null}this[V]=!!e.async;this[x]=this[L]?new p.StringDecoder(this[L]):null;e&&e.debugExposeBuffer===true&&Object.defineProperty(this,"buffer",{get:()=>this[O]});e&&e.debugExposePipes===true&&Object.defineProperty(this,"pipes",{get:()=>this[R]});const{signal:s}=e;if(s){this[z]=s;s.aborted?this[Y]():s.addEventListener("abort",(()=>this[Y]()))}}get bufferLength(){return this[B]}get encoding(){return this[L]}
/**
   * @deprecated - This is a read only property
   */set encoding(t){throw new Error("Encoding must be set at instantiation time")}
/**
   * @deprecated - Encoding may only be set at instantiation time
   */setEncoding(t){throw new Error("Encoding must be set at instantiation time")}get objectMode(){return this[T]}
/**
   * @deprecated - This is a read-only property
   */set objectMode(t){throw new Error("objectMode must be set at instantiation time")}get async(){return this[V]}set async(t){this[V]=this[V]||!!t}[Y](){this[q]=true;this.emit("abort",this[z]?.reason);this.destroy(this[z]?.reason)}get aborted(){return this[q]}set aborted(t){}write(t,e,s){if(this[q])return false;if(this[b])throw new Error("write after end");if(this[C]){this.emit("error",Object.assign(new Error("Cannot call write after a stream was destroyed"),{code:"ERR_STREAM_DESTROYED"}));return true}if(typeof e==="function"){s=e;e="utf8"}e||(e="utf8");const i=this[V]?defer:nodefer;if(!this[T]&&!f.isBuffer(t))if(isArrayBufferView(t))t=f.from(t.buffer,t.byteOffset,t.byteLength);else if(isArrayBufferLike(t))t=f.from(t);else if(typeof t!=="string")throw new Error("Non-contiguous data written to non-objectMode stream");if(this[T]){this[P]&&this[B]!==0&&this[j](true);this[P]?this.emit("data",t):this[W](t);this[B]!==0&&this.emit("readable");s&&i(s);return this[P]}if(!t.length){this[B]!==0&&this.emit("readable");s&&i(s);return this[P]}typeof t!=="string"||e===this[L]&&!this[x]?.lastNeed||(t=f.from(t,e));f.isBuffer(t)&&this[L]&&(t=this[x].write(t));this[P]&&this[B]!==0&&this[j](true);this[P]?this.emit("data",t):this[W](t);this[B]!==0&&this.emit("readable");s&&i(s);return this[P]}read(t){if(this[C])return null;this[H]=false;if(this[B]===0||t===0||t&&t>this[B]){this[y]();return null}this[T]&&(t=null);this[O].length>1&&!this[T]&&(this[O]=[this[L]?this[O].join(""):f.concat(this[O],this[B])]);const e=this[v](t||null,this[O][0]);this[y]();return e}[v](t,e){if(this[T])this[D]();else{const s=e;if(t===s.length||t===null)this[D]();else if(typeof s==="string"){this[O][0]=s.slice(t);e=s.slice(0,t);this[B]-=t}else{this[O][0]=s.subarray(t);e=s.subarray(0,t);this[B]-=t}}this.emit("data",e);this[O].length||this[b]||this.emit("drain");return e}end(t,e,s){if(typeof t==="function"){s=t;t=void 0}if(typeof e==="function"){s=e;e="utf8"}t!==void 0&&this.write(t,e);s&&this.once("end",s);this[b]=true;this.writable=false;!this[P]&&this[_]||this[y]();return this}[A](){if(!this[C]){this[G]||this[R].length||(this[H]=true);this[_]=false;this[P]=true;this.emit("resume");this[O].length?this[j]():this[b]?this[y]():this.emit("drain")}}resume(){return this[A]()}pause(){this[P]=false;this[_]=true;this[H]=false}get destroyed(){return this[C]}get flowing(){return this[P]}get paused(){return this[_]}[W](t){this[T]?this[B]+=1:this[B]+=t.length;this[O].push(t)}[D](){this[T]?this[B]-=1:this[B]-=this[O][0].length;return this[O].shift()}[j](t=false){do{}while(this[M](this[D]())&&this[O].length);t||this[O].length||this[b]||this.emit("drain")}[M](t){this.emit("data",t);return this[P]}pipe(t,e){if(this[C])return t;this[H]=false;const s=this[g];e=e||{};t===c.stdout||t===c.stderr?e.end=false:e.end=e.end!==false;e.proxyErrors=!!e.proxyErrors;if(s)e.end&&t.end();else{this[R].push(e.proxyErrors?new PipeProxyErrors(this,t,e):new Pipe(this,t,e));this[V]?defer((()=>this[A]())):this[A]()}return t}unpipe(t){const e=this[R].find((e=>e.dest===t));if(e){if(this[R].length===1){this[P]&&this[G]===0&&(this[P]=false);this[R]=[]}else this[R].splice(this[R].indexOf(e),1);e.unpipe()}}addListener(t,e){return this.on(t,e)}on(t,e){const s=super.on(t,e);if(t==="data"){this[H]=false;this[G]++;this[R].length||this[P]||this[A]()}else if(t==="readable"&&this[B]!==0)super.emit("readable");else if(isEndish(t)&&this[g]){super.emit(t);this.removeAllListeners(t)}else if(t==="error"&&this[S]){const t=e;this[V]?defer((()=>t.call(this,this[S]))):t.call(this,this[S])}return s}removeListener(t,e){return this.off(t,e)}off(t,e){const s=super.off(t,e);if(t==="data"){this[G]=this.listeners("data").length;this[G]!==0||this[H]||this[R].length||(this[P]=false)}return s}removeAllListeners(t){const e=super.removeAllListeners(t);if(t==="data"||t===void 0){this[G]=0;this[H]||this[R].length||(this[P]=false)}return e}get emittedEnd(){return this[g]}[y](){if(!this[E]&&!this[g]&&!this[C]&&this[O].length===0&&this[b]){this[E]=true;this.emit("end");this.emit("prefinish");this.emit("finish");this[w]&&this.emit("close");this[E]=false}}emit(t,...e){const s=e[0];if(t!=="error"&&t!=="close"&&t!==C&&this[C])return false;if(t==="data")return!(!this[T]&&!s)&&(this[V]?(defer((()=>this[N](s))),true):this[N](s));if(t==="end")return this[k]();if(t==="close"){this[w]=true;if(!this[g]&&!this[C])return false;const t=super.emit("close");this.removeAllListeners("close");return t}if(t==="error"){this[S]=s;super.emit(I,s);const t=!(this[z]&&!this.listeners("error").length)&&super.emit("error",s);this[y]();return t}if(t==="resume"){const t=super.emit("resume");this[y]();return t}if(t==="finish"||t==="prefinish"){const e=super.emit(t);this.removeAllListeners(t);return e}const i=super.emit(t,...e);this[y]();return i}[N](t){for(const e of this[R])e.dest.write(t)===false&&this.pause();const e=!this[H]&&super.emit("data",t);this[y]();return e}[k](){if(this[g])return false;this[g]=true;this.readable=false;return this[V]?(defer((()=>this[F]())),true):this[F]()}[F](){if(this[x]){const t=this[x].end();if(t){for(const e of this[R])e.dest.write(t);this[H]||super.emit("data",t)}}for(const t of this[R])t.end();const t=super.emit("end");this.removeAllListeners("end");return t}async collect(){const t=Object.assign([],{dataLength:0});this[T]||(t.dataLength=0);const e=this.promise();this.on("data",(e=>{t.push(e);this[T]||(t.dataLength+=e.length)}));await e;return t}async concat(){if(this[T])throw new Error("cannot concat in objectMode");const t=await this.collect();return this[L]?t.join(""):f.concat(t,t.dataLength)}async promise(){return new Promise(((t,e)=>{this.on(C,(()=>e(new Error("stream destroyed"))));this.on("error",(t=>e(t)));this.on("end",(()=>t()))}))}[Symbol.asyncIterator](){this[H]=false;let t=false;const stop=async()=>{this.pause();t=true;return{value:void 0,done:true}};const next=()=>{if(t)return stop();const e=this.read();if(e!==null)return Promise.resolve({done:false,value:e});if(this[b])return stop();let s;let i;const onerr=t=>{this.off("data",ondata);this.off("end",onend);this.off(C,ondestroy);stop();i(t)};const ondata=t=>{this.off("error",onerr);this.off("end",onend);this.off(C,ondestroy);this.pause();s({value:t,done:!!this[b]})};const onend=()=>{this.off("error",onerr);this.off("data",ondata);this.off(C,ondestroy);stop();s({done:true,value:void 0})};const ondestroy=()=>onerr(new Error("stream destroyed"));return new Promise(((t,e)=>{i=e;s=t;this.once(C,ondestroy);this.once("error",onerr);this.once("end",onend);this.once("data",ondata)}))};return{next:next,throw:stop,return:stop,[Symbol.asyncIterator](){return this}}}[Symbol.iterator](){this[H]=false;let t=false;const stop=()=>{this.pause();this.off(I,stop);this.off(C,stop);this.off("end",stop);t=true;return{done:true,value:void 0}};const next=()=>{if(t)return stop();const e=this.read();return e===null?stop():{done:false,value:e}};this.once("end",stop);this.once(I,stop);this.once(C,stop);return{next:next,throw:stop,return:stop,[Symbol.iterator](){return this}}}destroy(t){if(this[C]){t?this.emit("error",t):this.emit(C);return this}this[C]=true;this[H]=true;this[O].length=0;this[B]=0;const e=this;typeof e.close!=="function"||this[w]||e.close();t?this.emit("error",t):this.emit(C);return this}
/**
   * Alias for {@link isStream}
   *
   * Former export location, maintained for backwards compatibility.
   *
   * @deprecated
   */static get isStream(){return a.isStream}}a.Minipass=Minipass;const J=a.__esModule;const K=a.Minipass,Q=a.isWritable,U=a.isReadable,X=a.isStream;export{K as Minipass,J as __esModule,a as default,U as isReadable,X as isStream,Q as isWritable};

