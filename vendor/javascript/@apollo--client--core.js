// @apollo/client/core@4.0.4 downloaded from https://ga.jspm.io/npm:@apollo/client@4.0.4/core/index.js

import{OperationTypeNode as e,visit as t,BREAK as r,Kind as s}from"graphql";import{BehaviorSubject as i,tap as a,Subject as o,Observable as n,share as c,mergeMap as l,from as u,map as h,lastValueFrom as f,of as d,catchError as p,filter as y,finalize as m,shareReplay as v,throwError as g,materialize as k,EMPTY as w,concat as q}from"rxjs";import{NotImplementedHandler as P}from"@apollo/client/incremental";import{execute as O}from"@apollo/client/link";export{ApolloLink,concat,empty,execute,from,split}from"@apollo/client/link";import{isNetworkRequestInFlight as S,DocumentTransform as Q,cacheSizes as C,print as x}from"@apollo/client/utilities";export{DocumentTransform,Observable,isNetworkRequestSettled,isReference}from"@apollo/client/utilities";import{__DEV__ as M}from"@apollo/client/utilities/environment";import{getOperationDefinition as R,filterMap as D,equalByQuery as F,getQueryDefinition as I,getOperationName as N,compact as T,toQueryResult as E,preventUnhandledRejection as W,graphQLResultHasError as L,checkDocument as V,AutoCleanedWeakCache as _,getDefaultValues as j,removeDirectivesFromDocument as B,hasDirectives as U,hasForcedResolvers as A,isDocumentNode as H,isNonNullObject as z,makeUniqueId as G,mergeOptions as Y,removeMaskedFragmentSpreads as $,getApolloClientMemoryInternals as K}from"@apollo/client/utilities/internal";import{invariant as J,newInvariantError as X}from"@apollo/client/utilities/invariant";export{setVerbosity as setLogVerbosity}from"@apollo/client/utilities/invariant";import{v as Z}from"../_/BW1JkdTH.js";export{b as build}from"../_/BW1JkdTH.js";import{Trie as ee}from"@wry/trie";import{canonicalStringify as te}from"@apollo/client/cache";export{ApolloCache,InMemoryCache,MissingFieldError,defaultDataIdFromObject,makeVar}from"@apollo/client/cache";import{CombinedGraphQLErrors as re,graphQLResultHasProtocolErrors as se,PROTOCOL_ERRORS_SYMBOL as ie,toErrorLike as ae,registerLinkError as oe}from"@apollo/client/errors";export{CombinedGraphQLErrors,CombinedProtocolErrors,LinkError,LocalStateError,ServerError,ServerParseError,UnconventionalError}from"@apollo/client/errors";import{maskOperation as ne,maskFragment as ce}from"@apollo/client/masking";import{equal as le}from"@wry/equality";export{HttpLink,checkFetcher,createHttpLink,createSignalIfSupported,defaultPrinter,fallbackHttpConfig,parseAndCheckHttpResponse,rewriteURIForGET,selectHttpOptionsAndBody,selectHttpOptionsAndBodyInternal,selectURI}from"@apollo/client/link/http";export{disableExperimentalFragmentVariables,disableFragmentWarnings,enableExperimentalFragmentVariables,gql,resetCaches}from"graphql-tag";var ue;(function(e){e[e.loading=1]="loading";e[e.setVariables=2]="setVariables";e[e.fetchMore=3]="fetchMore";e[e.refetch=4]="refetch";e[e.poll=6]="poll";e[e.ready=7]="ready";e[e.error=8]="error";e[e.streaming=9]="streaming"})(ue||(ue={}));const{assign:he,hasOwnProperty:fe}=Object;const de={loading:true,networkStatus:ue.loading,data:void 0,dataState:"empty",partial:true};const be={loading:false,networkStatus:ue.ready,data:void 0,dataState:"empty",partial:true};class ObservableQuery{options;queryName;
/**
    * @internal will be read and written from `QueryInfo`
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
_lastWrite;get query(){return this.lastQuery}get variables(){return this.options.variables}unsubscribeFromCache;input;subject;isTornDown;queryManager;subscriptions=new Set;waitForNetworkResult;lastQuery;linkSubscription;pollingInfo;get networkStatus(){return this.subject.getValue().result.networkStatus}constructor({queryManager:e,options:t,transformedQuery:r=e.transform(t.query)}){this.queryManager=e;this.waitForNetworkResult=t.fetchPolicy==="network-only";this.isTornDown=false;this.subscribeToMore=this.subscribeToMore.bind(this);this.maskResult=this.maskResult.bind(this);const{watchQuery:{fetchPolicy:s="cache-first"}={}}=e.defaultOptions;const{fetchPolicy:i=s,initialFetchPolicy:a=(i==="standby"?s:i)}=t;this.lastQuery=r;this.options={...t,initialFetchPolicy:a,fetchPolicy:i,variables:this.getVariablesWithDefaults(t.variables)};this.initializeObservablesQueue();this["@@observable"]=()=>this;Symbol.observable&&(this[Symbol.observable]=()=>this);const o=R(this.query);this.queryName=o&&o.name&&o.name.value}initializeObservablesQueue(){this.subject=new i({query:this.query,variables:this.variables,result:de,meta:{}});const e=this.subject.pipe(a({subscribe:()=>{if(!this.subject.observed){this.reobserve();setTimeout((()=>this.updatePolling()))}},unsubscribe:()=>{this.subject.observed||this.tearDownQuery()}}),D((({query:e,variables:t,result:r,meta:s},i)=>{const{shouldEmit:a}=s;if(r===de){i.previous=void 0;i.previousVariables=void 0}if(this.options.fetchPolicy==="standby"||a===2)return;if(a===1)return c();const{previous:o,previousVariables:n}=i;if(o){const s=this.queryManager.getDocumentInfo(e);const i=this.queryManager.dataMasking;const a=i?s.nonReactiveQuery:e;const c=i||s.hasNonreactiveDirective?F(a,o,r,t):le(o,r);if(c&&le(n,t))return}if(a!==3||this.options.notifyOnNetworkStatusChange&&!le(o,r))return c();function c(){i.previous=r;i.previousVariables=t;return r}}),(()=>({}))));this.pipe=e.pipe.bind(e);this.subscribe=e.subscribe.bind(e);this.input=new o;this.input.complete=()=>{};this.input.pipe(this.operator).subscribe(this.subject)}
/**
     * Subscribes to the `ObservableQuery`.
     * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,
     * or the `next` handler that is called for each value emitted from the subscribed Observable.
     * @returns A subscription reference to the registered handlers.
     */
subscribe;
/**
     * Used to stitch together functional operators into a chain.
     *
     * @example
     *
     * ```ts
     * import { filter, map } from 'rxjs';
     *
     * observableQuery
     *   .pipe(
     *     filter(...),
     *     map(...),
     *   )
     *   .subscribe(x => console.log(x));
     * ```
     *
     * @returns The Observable result of all the operators having been called
     * in the order they were passed in.
     */
pipe;[Symbol.observable];"@@observable";
/**
    * @internal
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
getCacheDiff({optimistic:e=true}={}){return this.queryManager.cache.diff({query:this.query,variables:this.variables,returnPartialData:true,optimistic:e})}getInitialResult(e){const t=this.queryManager.prioritizeCacheValues?"cache-first":e||this.options.fetchPolicy;const r=()=>{const e=this.getCacheDiff();const t=this.options.returnPartialData||e.complete?e.result??void 0:void 0;return this.maskResult({data:t,dataState:e.complete?"complete":t===void 0?"empty":"partial",loading:!e.complete,networkStatus:e.complete?ue.ready:ue.loading,partial:!e.complete})};switch(t){case"cache-only":return{...r(),loading:false,networkStatus:ue.ready};case"cache-first":return r();case"cache-and-network":return{...r(),loading:true,networkStatus:ue.loading};case"standby":return be;default:return de}}resubscribeCache(){const{variables:e,fetchPolicy:t}=this.options;const r=this.query;const s=t==="standby"||t==="no-cache"||this.waitForNetworkResult;const i=!ye({query:r,variables:e},this.unsubscribeFromCache)&&!this.waitForNetworkResult;(s||i)&&this.unsubscribeFromCache?.();if(s||!i)return;const a={query:r,variables:e,optimistic:true,watcher:this,callback:e=>{const t=this.queryManager.getDocumentInfo(r);(t.hasClientExports||t.hasForcedResolvers)&&(a.lastDiff=void 0);if(a.lastOwnDiff===e)return;const{result:s}=this.subject.getValue();(e.complete||!s.error&&s!==de&&s!==be)&&(le(s.data,e.result)||this.scheduleNotify())}};const o=this.queryManager.cache.watch(a);this.unsubscribeFromCache=Object.assign((()=>{this.unsubscribeFromCache=void 0;o()}),{query:r,variables:e})}stableLastResult;getCurrentResult(){const{result:e}=this.subject.getValue();let t=e.networkStatus===ue.error||this.hasObservers()||this.options.fetchPolicy==="no-cache"?e:this.getInitialResult();t===de&&(t=this.getInitialResult());le(this.stableLastResult,t)||(this.stableLastResult=t);return this.stableLastResult}
/**
     * Update the variables of this observable query, and fetch the new results.
     * This method should be preferred over `setVariables` in most use cases.
     *
     * Returns a `ResultPromise` with an additional `.retain()` method. Calling
     * `.retain()` keeps the network operation running even if the `ObservableQuery`
     * no longer requires the result.
     *
     * Note: `refetch()` guarantees that a value will be emitted from the
     * observable, even if the result is deep equal to the previous value.
     *
     * @param variables - The new set of variables. If there are missing variables,
     * the previous values of those variables will be used.
     */refetch(e){const{fetchPolicy:t}=this.options;const r={pollInterval:0};r.fetchPolicy=t==="no-cache"?"no-cache":"network-only";if(M&&e&&fe.call(e,"variables")){const t=I(this.query);const r=t.variableDefinitions;r&&r.some((e=>e.variable.name.value==="variables"))||M&&J.warn(77,e,t.name?.value||t)}e&&!le(this.variables,e)&&(r.variables=this.options.variables=this.getVariablesWithDefaults({...this.variables,...e}));this._lastWrite=void 0;return this._reobserve(r,{newNetworkStatus:ue.refetch})}fetchMore({query:e,variables:t,context:r,errorPolicy:s,updateQuery:i}){J(this.options.fetchPolicy!=="cache-only",78,N(this.query,"(anonymous)"));const a={...T(this.options,{errorPolicy:"none"},{query:e,context:r,errorPolicy:s}),variables:e?t:{...this.variables,...t},fetchPolicy:"no-cache",notifyOnNetworkStatusChange:this.options.notifyOnNetworkStatusChange};a.query=this.transformDocument(a.query);this.lastQuery=e?this.transformDocument(this.options.query):a.query;let o=false;const n=this.options.fetchPolicy!=="no-cache";n||J(i,79);const{finalize:c,pushNotification:l}=this.pushOperation(ue.fetchMore);l({source:"newNetworkStatus",kind:"N",value:{}},{shouldEmit:3});return this.queryManager.fetchQuery(a,ue.fetchMore).then((e=>{c();if(n)this.queryManager.cache.batch({update:t=>{i?t.updateQuery({query:this.query,variables:this.variables,returnPartialData:true,optimistic:false},(t=>i(t,{fetchMoreResult:e.data,variables:a.variables}))):t.writeQuery({query:a.query,variables:a.variables,data:e.data})},onWatchUpdated:e=>{e.watcher===this&&(o=true)}});else{const t=this.getCurrentResult();const r=i(t.data,{fetchMoreResult:e.data,variables:a.variables});l({kind:"N",value:{...t,networkStatus:ue.ready,loading:false,data:r,dataState:t.dataState==="streaming"?"streaming":"complete"},source:"network"})}return this.maskResult(e)})).finally((()=>{c();n&&!o&&l({kind:"N",source:"newNetworkStatus",value:{}},{shouldEmit:1})}))}subscribeToMore(e){const t=this.queryManager.startGraphQLSubscription({query:e.document,variables:e.variables,context:e.context}).subscribe({next:t=>{const{updateQuery:r,onError:s}=e;const{error:i}=t;i?s?s(i):J.error(80,i):r&&this.updateQuery(((e,s)=>r(e,{subscriptionData:t,...s})))}});this.subscriptions.add(t);return()=>{this.subscriptions.delete(t)&&t.unsubscribe()}}
/**
    * @internal
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */applyOptions(e){const t=T(this.options,e||{});he(this.options,t);this.updatePolling()}
/**
     * Update the variables of this observable query, and fetch the new results
     * if they've changed. Most users should prefer `refetch` instead of
     * `setVariables` in order to to be properly notified of results even when
     * they come from the cache.
     *
     * Note: `setVariables()` guarantees that a value will be emitted from the
     * observable, even if the result is deeply equal to the previous value.
     *
     * Note: the promise will resolve with the last emitted result
     * when either the variables match the current variables or there
     * are no subscribers to the query.
     *
     * @param variables - The new set of variables. If there are missing variables,
     * the previous values of those variables will be used.
     */async setVariables(e){e=this.getVariablesWithDefaults(e);if(le(this.variables,e))return E(this.getCurrentResult());this.options.variables=e;return this.hasObservers()?this._reobserve({fetchPolicy:this.options.initialFetchPolicy,variables:e},{newNetworkStatus:ue.setVariables}):E(this.getCurrentResult())}updateQuery(e){const{queryManager:t}=this;const{result:r,complete:s}=this.getCacheDiff({optimistic:false});const i=e(r,{variables:this.variables,complete:!!s,previousData:r});if(i){t.cache.writeQuery({query:this.options.query,data:i,variables:this.variables});t.broadcastQueries()}}startPolling(e){this.options.pollInterval=e;this.updatePolling()}stopPolling(){this.options.pollInterval=0;this.updatePolling()}applyNextFetchPolicy(e,t){if(t.nextFetchPolicy){const{fetchPolicy:r="cache-first",initialFetchPolicy:s=r}=t;r==="standby"||(typeof t.nextFetchPolicy==="function"?t.fetchPolicy=t.nextFetchPolicy.call(t,r,{reason:e,options:t,observable:this,initialFetchPolicy:s}):t.fetchPolicy=e==="variables-changed"?s:t.nextFetchPolicy)}return t.fetchPolicy}fetch(e,t,r,s){const i=this.options.fetchPolicy;e.context??={};let o=false;const l=()=>{o=true};const u=e=>new n((r=>{try{return e.subscribe({next(e){o=true;r.next(e)},error:e=>r.error(e),complete:()=>r.complete()})}finally{if(!o){p.override=t;this.input.next({kind:"N",source:"newNetworkStatus",value:{resetError:true},query:d,variables:b,meta:{shouldEmit:3,fetchPolicy:i}})}}}));let{observable:h,fromLink:f}=this.queryManager.fetchObservableWithInfo(e,{networkStatus:t,query:r,onCacheHit:l,fetchQueryOperator:u,observableQuery:this});const{query:d,variables:b}=this;const p={abort:()=>{m.unsubscribe()},query:d,variables:b};this.activeOperations.add(p);let y=t==ue.refetch||t==ue.setVariables;h=h.pipe(s,c());const m=h.pipe(a({next:e=>{e.source==="newNetworkStatus"||e.kind==="N"&&e.value.loading?p.override=t:delete p.override},finalize:()=>this.activeOperations.delete(p)})).subscribe({next:e=>{const t={};if(y&&e.kind==="N"&&"loading"in e.value&&!e.value.loading){y=false;t.shouldEmit=1}this.input.next({...e,query:d,variables:b,meta:t})}});return{fromLink:f,subscription:m,observable:h}}didWarnCacheOnlyPolling=false;updatePolling(){if(this.queryManager.ssrMode)return;const{pollingInfo:e,options:{fetchPolicy:t,pollInterval:r}}=this;if(!r||!this.hasObservers()||t==="cache-only"){if(M&&!this.didWarnCacheOnlyPolling&&r&&t==="cache-only"){M&&J.warn(81,N(this.query,"(anonymous)"));this.didWarnCacheOnlyPolling=true}this.cancelPolling();return}if(e?.interval===r)return;const s=e||(this.pollingInfo={});s.interval=r;const i=()=>{this.pollingInfo&&(S(this.networkStatus)||this.options.skipPollAttempt?.()?a():this._reobserve({fetchPolicy:this.options.initialFetchPolicy==="no-cache"?"no-cache":"network-only"},{newNetworkStatus:ue.poll}).then(a,a))};const a=()=>{const e=this.pollingInfo;if(e){clearTimeout(e.timeout);e.timeout=setTimeout(i,e.interval)}};a()}cancelPolling(){if(this.pollingInfo){clearTimeout(this.pollingInfo.timeout);delete this.pollingInfo}}reobserve(e){return this._reobserve(e)}_reobserve(e,t){this.isTornDown=false;let{newNetworkStatus:r}=t||{};this.queryManager.obsQueries.add(this);const s=r===ue.refetch||r===ue.poll;const i=this.variables;const a=this.options.fetchPolicy;const o=T(this.options,e||{});const n=s?o:he(this.options,o);const c=this.transformDocument(n.query);this.lastQuery=c;e&&"variables"in e&&(n.variables=this.getVariablesWithDefaults(e.variables));if(!s){this.updatePolling();if(e&&e.variables&&!le(e.variables,i)&&n.fetchPolicy!=="standby"&&(n.fetchPolicy===a||typeof n.nextFetchPolicy==="function")){this.applyNextFetchPolicy("variables-changed",n);r===void 0&&(r=ue.setVariables)}}const l=this.networkStatus;if(!r){r=ue.loading;l!==ue.loading&&e?.variables&&!le(e.variables,i)&&(r=ue.setVariables);n.fetchPolicy==="standby"&&(r=ue.ready)}n.fetchPolicy==="standby"&&this.cancelPolling();this.resubscribeCache();const{promise:u,operator:h}=me((e=>{switch(e.kind){case"E":throw e.error;case"N":if(e.source!=="newNetworkStatus"&&!e.value.loading)return e.value}}),n.fetchPolicy==="standby"?{data:void 0}:void 0);const{subscription:f,observable:d,fromLink:b}=this.fetch(n,r,c,h);if(!s&&(b||!this.linkSubscription)){this.linkSubscription&&this.linkSubscription.unsubscribe();this.linkSubscription=f}const p=Object.assign(W(u.then((e=>E(this.maskResult(e)))).finally((()=>{this.hasObservers()||this.activeOperations.size!==0||this.tearDownQuery()}))),{retain:()=>{const e=d.subscribe({});const t=()=>e.unsubscribe();u.then(t,t);return p}});return p}hasObservers(){return this.subject.observed}stop(){this.subject.complete();this.initializeObservablesQueue();this.tearDownQuery()}tearDownQuery(){if(!this.isTornDown){this.resetNotifications();this.unsubscribeFromCache?.();if(this.linkSubscription){this.linkSubscription.unsubscribe();delete this.linkSubscription}this.stopPolling();this.subscriptions.forEach((e=>e.unsubscribe()));this.subscriptions.clear();this.queryManager.obsQueries.delete(this);this.isTornDown=true;this.abortActiveOperations();this._lastWrite=void 0}}transformDocument(e){return this.queryManager.transform(e)}maskResult(e){const t=this.queryManager.maskOperation({document:this.query,data:e.data,fetchPolicy:this.options.fetchPolicy,cause:this});return t===e.data?e:{...e,data:t}}dirty=false;notifyTimeout;
/**
    * @internal
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
resetNotifications(){if(this.notifyTimeout){clearTimeout(this.notifyTimeout);this.notifyTimeout=void 0}this.dirty=false}
/**
    * @internal
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */scheduleNotify(){if(!this.dirty){this.dirty=true;this.notifyTimeout||(this.notifyTimeout=setTimeout((()=>this.notify(true)),0))}}
/**
    * @internal
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */notify(e=false){if(!e){const e=this.queryManager.getDocumentInfo(this.query);if(e.hasClientExports||e.hasForcedResolvers)return}const{dirty:t}=this;this.resetNotifications();if(t&&(this.options.fetchPolicy=="cache-only"||this.options.fetchPolicy=="cache-and-network"||!this.activeOperations.size)){const e=this.getCacheDiff();le(e.result,this.getCacheDiff({optimistic:false}).result)?this.reobserveCacheFirst():this.input.next({kind:"N",value:{data:e.result,dataState:e.complete?"complete":e.result?"partial":"empty",networkStatus:ue.ready,loading:false,error:void 0,partial:!e.complete},source:"cache",query:this.query,variables:this.variables,meta:{}})}}activeOperations=new Set;pushOperation(e){let t=false;const{query:r,variables:s}=this;const i=()=>{this.activeOperations.delete(a)};const a={override:e,abort:()=>{t=true;i()},query:r,variables:s};this.activeOperations.add(a);return{finalize:i,pushNotification:(e,i)=>{t||this.input.next({...e,query:r,variables:s,meta:{...i}})}}}calculateNetworkStatus(e){if(e===ue.streaming)return e;const t=Array.from(this.activeOperations.values()).findLast((e=>ye(e,this)&&e.override!==void 0));return t?.override??e}abortActiveOperations(){this.activeOperations.forEach((e=>e.abort()))}
/**
    * @internal
    * Called from `clearStore`.
    *
    * - resets the query to its initial state
    * - cancels all active operations and their subscriptions
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */reset(){const e=this.options.fetchPolicy==="cache-only";this.setResult(e?be:de,{shouldEmit:e?1:2});this.abortActiveOperations()}
/**
    * @internal
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */setResult(e,t){this.input.next({source:"setResult",kind:"N",value:e,query:this.query,variables:this.variables,meta:{...t}})}operator=D((e=>{const{query:t,variables:r,meta:s}=e;if(e.source==="setResult")return{query:t,variables:r,result:e.value,meta:s};if(e.kind==="C"||!ye(e,this))return;let i;const a=this.subject.getValue();if(e.source==="cache"){i=e.value;if(i.networkStatus===ue.ready&&i.partial&&(!this.options.returnPartialData||a.result.networkStatus===ue.error)&&this.options.fetchPolicy!=="cache-only")return}else if(e.source==="network"){if(this.waitForNetworkResult){this.waitForNetworkResult=false;this.resubscribeCache()}i=e.kind==="E"?{...ye(a,e)?a.result:{data:void 0,dataState:"empty",partial:true},error:e.error,networkStatus:ue.error,loading:false}:e.value;e.kind==="E"&&i.dataState==="streaming"&&(i.dataState="complete");i.error&&(s.shouldEmit=1)}else if(e.source==="newNetworkStatus"){const t=ye(a,e)?a.result:this.getInitialResult(s.fetchPolicy);const{resetError:r}=e.value;const o=r?void 0:t.error;const n=o?ue.error:ue.ready;i={...t,error:o,networkStatus:n}}J(i);i.error||delete i.error;i.networkStatus=this.calculateNetworkStatus(i.networkStatus);i.loading=S(i.networkStatus);i=this.maskResult(i);return{query:t,variables:r,result:i,meta:s}}));reobserveCacheFirst(){const{fetchPolicy:e,nextFetchPolicy:t}=this.options;e==="cache-and-network"||e==="network-only"?this.reobserve({fetchPolicy:"cache-first",nextFetchPolicy(r,s){this.nextFetchPolicy=t;return typeof this.nextFetchPolicy==="function"?this.nextFetchPolicy(r,s):e}}):this.reobserve()}getVariablesWithDefaults(e){return this.queryManager.getVariables(this.query,e)}}function pe(e){M&&e&&M&&J.debug(82,e)}function ye(e,t){return!!(e&&t&&e.query===t.query&&le(e.variables,t.variables))}function me(e,t){let r,s,i=t;const o=new Promise(((e,t)=>{r=e;s=t}));const n=a({next(t){try{const r=e(t);r!==void 0&&(i=r)}catch(e){s(e)}},finalize:()=>{if(i)r(i);else{const e="The operation was aborted.";const t="AbortError";s(typeof DOMException!=="undefined"?new DOMException(e,t):Object.assign(new Error(e),{name:t}))}}});return{promise:o,operator:n}}const ve={};const ge=new WeakMap;function ke(e,t){const r=e[t];typeof r==="function"&&(e[t]=function(){ge.set(e,(ge.get(e)+1)%1e15);return r.apply(this,arguments)})}const we=new WeakMap;class QueryInfo{lastRequestId=1;cache;queryManager;id;observableQuery;incremental;constructor(e,t){const r=this.cache=e.cache;const s=(we.get(e)||0)+1;we.set(e,s);this.id=s+"";this.observableQuery=t;this.queryManager=e;if(!ge.has(r)){ge.set(r,0);ke(r,"evict");ke(r,"modify");ke(r,"reset")}}
/**
    * @internal
    * For feud-preventing behaviour, `lastWrite` should be shared by all `QueryInfo` instances of an `ObservableQuery`.
    * In the case of a standalone `QueryInfo`, we will keep a local version.
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */_lastWrite;get lastWrite(){return(this.observableQuery||this)._lastWrite}set lastWrite(e){(this.observableQuery||this)._lastWrite=e}resetLastWrite(){this.lastWrite=void 0}shouldWrite(e,t){const{lastWrite:r}=this;return!(r&&r.dmCount===ge.get(this.cache)&&le(t,r.variables)&&le(e.data,r.result.data))}get hasNext(){return!!this.incremental&&this.incremental.hasNext}maybeHandleIncrementalResult(e,t,r){const{incrementalHandler:s}=this.queryManager;if(s.isIncrementalResult(t)){this.incremental||=s.startRequest({query:r});return this.incremental.handle(e,t)}return t}markQueryResult(e,{document:t,variables:r,errorPolicy:s,cacheWriteBehavior:i}){const a={query:t,variables:r,returnPartialData:true,optimistic:true};this.observableQuery?.resetNotifications();const o=i===0;const n=o?void 0:this.cache.diff(a);let c=this.maybeHandleIncrementalResult(n?.result,e,t);if(o)return c;qe(c,s)?this.cache.batch({onWatchUpdated:(e,t)=>{e.watcher===this.observableQuery&&(e.lastOwnDiff=t)},update:e=>{if(this.shouldWrite(c,r)){e.writeQuery({query:t,data:c.data,variables:r,overwrite:i===1});this.lastWrite={result:c,variables:r,dmCount:ge.get(this.cache)}}else if(n&&n.complete){c={...c,data:n.result};return}const s=e.diff(a);s.complete&&(c={...c,data:s.result})}}):this.lastWrite=void 0;return c}markMutationResult(e,t,r=this.cache){const s=[];const i=t.cacheWriteBehavior===0;let a=this.maybeHandleIncrementalResult(i?void 0:r.diff({id:"ROOT_MUTATION",query:this.queryManager.getDocumentInfo(t.document).asQuery,variables:t.variables,optimistic:false,returnPartialData:true}).result,e,t.document);t.errorPolicy==="ignore"&&(a={...a,errors:[]});if(L(a)&&t.errorPolicy==="none")return Promise.resolve(a);const o=()=>({...a,dataState:this.hasNext?"streaming":"complete"});if(!i&&qe(a,t.errorPolicy)){s.push({result:a.data,dataId:"ROOT_MUTATION",query:t.document,variables:t.variables});const{updateQueries:e}=t;e&&this.queryManager.getObservableQueries("all").forEach((t=>{const r=t&&t.queryName;if(!r||!Object.hasOwnProperty.call(e,r))return;const i=e[r];const{query:a,variables:n}=t;const{result:c,complete:l}=t.getCacheDiff({optimistic:false});if(l&&c){const e=i(c,{mutationResult:o(),queryName:a&&N(a)||void 0,queryVariables:n});e&&s.push({result:e,dataId:"ROOT_QUERY",query:a,variables:n})}}))}let n=t.refetchQueries;typeof n==="function"&&(n=n(o()));if(s.length>0||(n||"").length>0||t.update||t.onQueryUpdated||t.removeOptimistic){const e=[];this.queryManager.refetchQueries({updateCache:e=>{i||s.forEach((t=>e.write(t)));const{update:r}=t;if(r){if(!i){const r=e.diff({id:"ROOT_MUTATION",query:this.queryManager.getDocumentInfo(t.document).asQuery,variables:t.variables,optimistic:false,returnPartialData:true});r.complete&&(a={...a,data:r.result})}this.hasNext||r(e,a,{context:t.context,variables:t.variables})}i||t.keepRootFields||this.hasNext||e.modify({id:"ROOT_MUTATION",fields(e,{fieldName:t,DELETE:r}){return t==="__typename"?e:r}})},include:n,optimistic:false,removeOptimistic:t.removeOptimistic,onQueryUpdated:t.onQueryUpdated||null}).forEach((t=>e.push(t)));if(t.awaitRefetchQueries||t.onQueryUpdated)return Promise.all(e).then((()=>a))}return Promise.resolve(a)}markMutationOptimistic(e,t){const r=typeof e==="function"?e(t.variables,{IGNORE:ve}):e;if(r===ve)return false;this.cache.recordOptimisticTransaction((e=>{try{this.markMutationResult({data:r},t,e)}catch(e){J.error(e)}}),this.id);return true}markSubscriptionResult(e,{document:t,variables:r,errorPolicy:s,cacheWriteBehavior:i}){if(i!==0){qe(e,s)&&this.cache.write({query:t,result:e.data,dataId:"ROOT_SUBSCRIPTION",variables:r});this.queryManager.broadcastQueries()}}}function qe(e,t="none"){const r=t==="ignore"||t==="all";let s=!L(e);!s&&r&&e.data&&(s=true);return s}class QueryManager{defaultOptions;client;clientOptions;assumeImmutableResults;documentTransform;ssrMode;defaultContext;dataMasking;incrementalHandler;localState;queryDeduplication;prioritizeCacheValues=false;onBroadcast;mutationStore;obsQueries=new Set;fetchCancelFns=new Map;constructor(e){const t=new Q((e=>this.cache.transformDocument(e)),{cache:false});this.client=e.client;this.defaultOptions=e.defaultOptions;this.queryDeduplication=e.queryDeduplication;this.clientOptions=e.clientOptions;this.ssrMode=e.ssrMode;this.assumeImmutableResults=e.assumeImmutableResults;this.dataMasking=e.dataMasking;this.localState=e.localState;this.incrementalHandler=e.incrementalHandler;const r=e.documentTransform;this.documentTransform=r?t.concat(r).concat(t):t;this.defaultContext=e.defaultContext||{};(this.onBroadcast=e.onBroadcast)&&(this.mutationStore={})}get link(){return this.client.link}get cache(){return this.client.cache}stop(){this.obsQueries.forEach((e=>e.stop()));this.cancelPendingFetches(X(83))}cancelPendingFetches(e){this.fetchCancelFns.forEach((t=>t(e)));this.fetchCancelFns.clear()}async mutate({mutation:e,variables:t,optimisticResponse:r,updateQueries:s,refetchQueries:i=[],awaitRefetchQueries:a=false,update:o,onQueryUpdated:n,fetchPolicy:c,errorPolicy:f,keepRootFields:d,context:b}){const p=new QueryInfo(this);e=this.cache.transformForLink(this.transform(e));const{hasClientExports:y}=this.getDocumentInfo(e);t=this.getVariables(e,t);if(y){M&&J(this.localState,84,N(e,"(anonymous)"));t=await this.localState.getExportedVariables({client:this.client,document:e,variables:t,context:b})}const m=this.mutationStore&&(this.mutationStore[p.id]={mutation:e,variables:t,loading:true,error:null});const v=r&&p.markMutationOptimistic(r,{document:e,variables:t,cacheWriteBehavior:c==="no-cache"?0:2,errorPolicy:f,context:b,updateQueries:s,update:o,keepRootFields:d});this.broadcastQueries();return new Promise(((y,g)=>{const k={};return this.getObservableFromLink(e,{...b,optimisticResponse:v?r:void 0},t,{},false).observable.pipe(Pe(),l((r=>{const l={...r};return u(p.markMutationResult(l,{document:e,variables:t,cacheWriteBehavior:c==="no-cache"?0:2,errorPolicy:f,context:b,update:o,updateQueries:s,awaitRefetchQueries:a,refetchQueries:i,removeOptimistic:v?p.id:void 0,onQueryUpdated:n,keepRootFields:d}))}))).pipe(h((e=>{const t=L(e);if(t&&f==="none")throw new re(e);if(m){m.loading=false;m.error=null}return e}))).subscribe({next:t=>{this.broadcastQueries();if(!p.hasNext){const r={data:this.maskOperation({document:e,data:t.data,fetchPolicy:c,cause:k})};L(t)&&(r.error=new re(t));Object.keys(t.extensions||{}).length&&(r.extensions=t.extensions);y(r)}},error:e=>{if(m){m.loading=false;m.error=e}v&&this.cache.removeOptimistic(p.id);this.broadcastQueries();if(f==="ignore")return y({data:void 0});if(f==="all")return y({data:void 0,error:e});g(e)}})}))}fetchQuery(t,r){V(t.query,e.QUERY);return(async()=>f(this.fetchObservableWithInfo(t,{networkStatus:r}).observable.pipe(D((e=>{switch(e.kind){case"E":throw e.error;case"N":if(e.source!=="newNetworkStatus")return E(e.value)}}))),{defaultValue:{data:void 0}}))()}transform(e){return this.documentTransform.transformDocument(e)}transformCache=new _(C["queryManager.getDocumentInfo"]||2e3);getDocumentInfo(e){const{transformCache:t}=this;if(!t.has(e)){const r=R(e);const s={hasClientExports:U(["client","export"],e,true),hasForcedResolvers:A(e),hasNonreactiveDirective:U(["nonreactive"],e),hasIncrementalDirective:U(["defer"],e),nonReactiveQuery:Se(e),clientQuery:U(["client"],e)?e:null,serverQuery:B([{name:"client",remove:true},{name:"connection"},{name:"nonreactive"},{name:"unmask"}],e),operationType:r?.operation,defaultVars:j(r),asQuery:{...e,definitions:e.definitions.map((e=>e.kind==="OperationDefinition"&&e.operation!=="query"?{...e,operation:"query"}:e))}};t.set(e,s)}const r=t.get(e);if(r.violation)throw r.violation;return r}getVariables(e,t){const r=this.getDocumentInfo(e).defaultVars;const s=Object.entries(t??{}).map((([e,t])=>[e,t===void 0?r[e]:t]));return{...r,...Object.fromEntries(s)}}watchQuery(t){V(t.query,e.QUERY);const r=this.transform(t.query);t={...t,variables:this.getVariables(r,t.variables)};typeof t.notifyOnNetworkStatusChange==="undefined"&&(t.notifyOnNetworkStatusChange=true);const s=new ObservableQuery({queryManager:this,options:t,transformedQuery:r});return s}query(e){const t=this.transform(e.query);return this.fetchQuery({...e,query:t}).then((r=>({...r,data:this.maskOperation({document:t,data:r?.data,fetchPolicy:e.fetchPolicy})})))}requestIdCounter=1;generateRequestId(){return this.requestIdCounter++}clearStore(e={discardWatches:true}){this.cancelPendingFetches(X(85));this.obsQueries.forEach((e=>{e.reset()}));this.mutationStore&&(this.mutationStore={});return this.cache.reset(e)}getObservableQueries(e="active"){const t=new Set;const r=new Map;const s=new Map;const i=new Set;Array.isArray(e)&&e.forEach((e=>{if(typeof e==="string"){r.set(e,e);s.set(e,false)}else if(H(e)){const t=x(this.transform(e));r.set(t,N(e));s.set(t,false)}else z(e)&&e.query&&i.add(e)}));this.obsQueries.forEach((r=>{const i=x(this.transform(r.options.query));if(e==="all"){t.add(r);return}const{queryName:a,options:{fetchPolicy:o}}=r;if((e!=="active"||o!=="standby")&&(e==="active"||a&&s.has(a)||i&&s.has(i))){t.add(r);a&&s.set(a,true);i&&s.set(i,true)}}));i.size&&i.forEach((e=>{const r=new ObservableQuery({queryManager:this,options:{...e,fetchPolicy:"network-only"}});t.add(r)}));M&&s.size&&s.forEach(((e,t)=>{if(!e){const e=r.get(t);e?M&&J.warn(86,e):M&&J.warn(87)}}));return t}refetchObservableQueries(e=false){const t=[];this.getObservableQueries(e?"all":"active").forEach((r=>{const{fetchPolicy:s}=r.options;!e&&s==="standby"||s==="cache-only"||t.push(r.refetch())}));this.broadcastQueries();return Promise.all(t)}startGraphQLSubscription(t){let{query:r,variables:s}=t;const{fetchPolicy:i,errorPolicy:a="none",context:o={},extensions:n={}}=t;V(r,e.SUBSCRIPTION);r=this.transform(r);s=this.getVariables(r,s);let c;M&&J(!this.getDocumentInfo(r).hasClientExports||this.localState,88,N(r,"(anonymous)"));const f=(this.getDocumentInfo(r).hasClientExports?u(this.localState.getExportedVariables({client:this.client,document:r,variables:s,context:o})):d(s)).pipe(l((e=>{const{observable:t,restart:s}=this.getObservableFromLink(r,o,e,n);const l=new QueryInfo(this);c=s;return t.pipe(h((t=>{l.markSubscriptionResult(t,{document:r,variables:e,errorPolicy:a,cacheWriteBehavior:i==="no-cache"?0:2});const s={data:t.data??void 0};if(L(t))s.error=new re(t);else if(se(t)){s.error=t.extensions[ie];delete t.extensions[ie]}t.extensions&&Object.keys(t.extensions).length&&(s.extensions=t.extensions);s.error&&a==="none"&&(s.data=void 0);a==="ignore"&&delete s.error;return s})),p((e=>d(a==="ignore"?{data:void 0}:{data:void 0,error:e}))),y((e=>!!(e.data||e.error))))})));return Object.assign(f,{restart:()=>c?.()})}broadcastQueries(){this.onBroadcast&&this.onBroadcast();this.obsQueries.forEach((e=>e.notify()))}inFlightLinkObservables=new ee(false);getObservableFromLink(t,r,s,i,a=r?.queryDeduplication??this.queryDeduplication){let o={};const{serverQuery:h,clientQuery:f,operationType:b,hasIncrementalDirective:y}=this.getDocumentInfo(t);const k=N(t);const w={client:this.client};if(h){const{inFlightLinkObservables:q,link:P}=this;try{const S=this.incrementalHandler.prepareRequest({query:h,variables:s,context:{...this.defaultContext,...r,queryDeduplication:a},extensions:i});r=S.context;function Q(e){return new n((t=>{function r(){return e.subscribe({next:t.next.bind(t),complete:t.complete.bind(t),error:t.error.bind(t)})}let s=r();o.restart||=()=>{s.unsubscribe();s=r()};return()=>{s.unsubscribe();o.restart=void 0}}))}if(a){const C=x(h);const D=te(s);o=q.lookup(C,D);o.observable||(o.observable=O(P,S,w).pipe(Q,m((()=>{q.peek(C,D)===o&&q.remove(C,D)})),b===e.SUBSCRIPTION?c():v({refCount:true})))}else o.observable=O(P,S,w).pipe(Q)}catch(F){o.observable=g((()=>F))}}else o.observable=d({data:{}});if(f){const{operation:I}=R(t);M&&J(this.localState,89,I[0].toUpperCase()+I.slice(1),k??"(anonymous)");J(!y,90,I[0].toUpperCase()+I.slice(1),k??"(anonymous)");o.observable=o.observable.pipe(l((e=>u(this.localState.execute({client:this.client,document:f,remoteResult:e,context:r,variables:s})))))}return{restart:()=>o.restart?.(),observable:o.observable.pipe(p((e=>{e=ae(e);oe(e);throw e})))}}getResultsFromLink(e,{queryInfo:t,cacheWriteBehavior:r,observableQuery:s}){const i=t.lastRequestId=this.generateRequestId();const{errorPolicy:a}=e;const o=this.cache.transformForLink(e.query);return this.getObservableFromLink(o,e.context,e.variables).observable.pipe(h((i=>{const n=t.markQueryResult(i,{...e,document:o,cacheWriteBehavior:r});const c=L(n);if(c&&a==="none"){t.resetLastWrite();s?.resetNotifications();throw new re(n)}const l={data:n.data,...t.hasNext?{loading:true,networkStatus:ue.streaming,dataState:"streaming",partial:true}:{dataState:n.data?"complete":"empty",loading:false,networkStatus:ue.ready,partial:!n.data}};if(c){if(a==="none"){l.data=void 0;l.dataState="empty"}if(a!=="ignore"){l.error=new re(n);l.dataState!=="streaming"&&(l.networkStatus=ue.error)}}return l})),p((e=>{if(i>=t.lastRequestId&&a==="none"){t.resetLastWrite();s?.resetNotifications();throw e}const r={data:void 0,dataState:"empty",loading:false,networkStatus:ue.ready,partial:true};if(a!=="ignore"){r.error=e;r.networkStatus=ue.error}return d(r)})))}fetchObservableWithInfo(e,{networkStatus:t=ue.loading,query:r=e.query,fetchQueryOperator:s=e=>e,onCacheHit:i=()=>{},observableQuery:a}){const h=this.getVariables(r,e.variables);const f=this.defaultOptions.watchQuery;let{fetchPolicy:d=f&&f.fetchPolicy||"cache-first",errorPolicy:b=f&&f.errorPolicy||"none",returnPartialData:p=false,notifyOnNetworkStatusChange:y=true,context:m={}}=e;!this.prioritizeCacheValues||d!=="network-only"&&d!=="cache-and-network"||(d="cache-first");const v=Object.assign({},e,{query:r,variables:h,fetchPolicy:d,errorPolicy:b,returnPartialData:p,notifyOnNetworkStatusChange:y,context:m});const g=new QueryInfo(this,a);const k=r=>{v.variables=r;const o=d==="no-cache"?0:t===ue.refetch&&v.refetchWritePolicy!=="merge"?1:2;const n=this.fetchQueryByPolicy(v,{queryInfo:g,cacheWriteBehavior:o,onCacheHit:i,observableQuery:a});n.observable=n.observable.pipe(s);v.fetchPolicy!=="standby"&&a?.applyNextFetchPolicy("after-fetch",e);return n};const w=()=>{this.fetchCancelFns.delete(g.id)};this.fetchCancelFns.set(g.id,(e=>{q.next({kind:"E",error:e,source:"network"})}));const q=new o;let P,O;if(this.getDocumentInfo(v.query).hasClientExports){M&&J(this.localState,91,N(v.query,"(anonymous)"));P=u(this.localState.getExportedVariables({client:this.client,document:v.query,variables:v.variables,context:v.context})).pipe(l((e=>k(e).observable)));O=true}else{const e=k(v.variables);O=e.fromLink;P=e.observable}return{observable:new n((e=>{e.add(w);P.subscribe(e);q.subscribe(e)})).pipe(c()),fromLink:O}}refetchQueries({updateCache:e,include:t,optimistic:r=false,removeOptimistic:s=(r?G("refetchQueries"):void 0),onQueryUpdated:i}){const a=new Map;t&&this.getObservableQueries(t).forEach((e=>{if(e.options.fetchPolicy==="cache-only")return;const t=e.getCurrentResult();a.set(e,{oq:e,lastDiff:{result:t?.data,complete:!t?.partial}})}));const o=new Map;if(e){const t=new Set;this.cache.batch({update:e,optimistic:r&&s||false,removeOptimistic:s,onWatchUpdated(e,r,s){const n=e.watcher;if(n instanceof ObservableQuery&&!t.has(n)){t.add(n);if(i){a.delete(n);let e=i(n,r,s);e===true&&(e=n.refetch().retain());e!==false&&o.set(n,e);return e}i!==null&&n.options.fetchPolicy!=="cache-only"&&a.set(n,{oq:n,lastDiff:s,diff:r})}}})}a.size&&a.forEach((({oq:e,lastDiff:t,diff:r})=>{let s;if(i){r||(r=e.getCacheDiff());s=i(e,r,t)}i&&s!==true||(s=e.refetch().retain());s!==false&&o.set(e,s)}));s&&this.cache.removeOptimistic(s);return o}noCacheWarningsByCause=new WeakSet;maskOperation(e){const{document:t,data:r}=e;if(M){const{fetchPolicy:r,cause:s={}}=e;const i=R(t)?.operation;if(this.dataMasking&&r==="no-cache"&&!Oe(t)&&!this.noCacheWarningsByCause.has(s)){this.noCacheWarningsByCause.add(s);M&&J.warn(92,N(t,`Unnamed ${i??"operation"}`))}}return this.dataMasking?ne(r,t,this.cache):r}maskFragment(e){const{data:t,fragment:r,fragmentName:s}=e;return this.dataMasking?ce(t,r,this.cache,s):t}fetchQueryByPolicy({query:e,variables:t,fetchPolicy:r,errorPolicy:s,returnPartialData:i,context:a},{cacheWriteBehavior:o,onCacheHit:n,queryInfo:c,observableQuery:l}){const f=()=>this.cache.diff({query:e,variables:t,returnPartialData:true,optimistic:true});const b=(r,o)=>{const c=r.result;M&&!i&&c!==null&&pe(r.missing);const l=e=>{r.complete||i||(e=void 0);return{data:e,dataState:r.complete?"complete":e?"partial":"empty",loading:S(o),networkStatus:o,partial:!r.complete}};const h=e=>d({kind:"N",value:l(e),source:"cache"});if((r.complete||i)&&this.getDocumentInfo(e).hasForcedResolvers){M&&J(this.localState,93,N(e,"(anonymous)"));n();return u(this.localState.execute({client:this.client,document:e,remoteResult:c?{data:c}:void 0,context:a,variables:t,onlyRunForcedResolvers:true,returnPartialData:true}).then((e=>({kind:"N",value:l(e.data||void 0),source:"cache"}))))}return s==="none"&&o===ue.refetch&&r.missing?h(void 0):h(c||void 0)};const p=()=>this.getResultsFromLink({query:e,variables:t,context:a,fetchPolicy:r,errorPolicy:s},{cacheWriteBehavior:o,queryInfo:c,observableQuery:l}).pipe(Pe(),k(),h((e=>({...e,source:"network"}))));switch(r){default:case"cache-first":{const e=f();return e.complete?{fromLink:false,observable:b(e,ue.ready)}:i?{fromLink:true,observable:q(b(e,ue.loading),p())}:{fromLink:true,observable:p()}}case"cache-and-network":{const e=f();return e.complete||i?{fromLink:true,observable:q(b(e,ue.loading),p())}:{fromLink:true,observable:p()}}case"cache-only":return{fromLink:false,observable:q(b(f(),ue.ready))};case"network-only":return{fromLink:true,observable:p()};case"no-cache":return{fromLink:true,observable:p()};case"standby":return{fromLink:false,observable:w}}}}function Pe(){let e=false;return a({next(){e=true},complete(){J(e,94)}})}function Oe(e){let s=true;t(e,{FragmentSpread:e=>{s=!!e.directives&&e.directives.some((e=>e.name.value==="unmask"));if(!s)return r}});return s}function Se(e){return t(e,{FragmentSpread:e=>{if(!e.directives?.some((e=>e.name.value==="unmask")))return{...e,directives:[...e.directives||[],{kind:s.DIRECTIVE,name:{kind:s.NAME,value:"nonreactive"}}]}}})}let Qe=false;class ApolloClient{link;cache;
/**
     * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`.
     */
disableNetworkFetches;set prioritizeCacheValues(e){this.queryManager.prioritizeCacheValues=e}get prioritizeCacheValues(){return this.queryManager.prioritizeCacheValues}version;queryDeduplication;defaultOptions;devtoolsConfig;queryManager;devToolsHookCb;resetStoreCallbacks=[];clearStoreCallbacks=[];constructor(e){if(M){J(e.cache,65);J(e.link,66)}const{cache:t,documentTransform:r,ssrMode:s=false,ssrForceFetchDelay:i=0,queryDeduplication:a=true,defaultOptions:o,defaultContext:n,assumeImmutableResults:c=t.assumeImmutableResults,localState:l,devtools:u,dataMasking:h,link:f,incrementalHandler:d=new P}=e;this.link=f;this.cache=t;this.queryDeduplication=a;this.defaultOptions=o||{};this.devtoolsConfig={...u,enabled:u?.enabled??M};this.watchQuery=this.watchQuery.bind(this);this.query=this.query.bind(this);this.mutate=this.mutate.bind(this);this.watchFragment=this.watchFragment.bind(this);this.resetStore=this.resetStore.bind(this);this.reFetchObservableQueries=this.refetchObservableQueries=this.refetchObservableQueries.bind(this);this.version=Z;this.queryManager=new QueryManager({client:this,defaultOptions:this.defaultOptions,defaultContext:n,documentTransform:r,queryDeduplication:a,ssrMode:s,dataMasking:!!h,clientOptions:e,incrementalHandler:d,assumeImmutableResults:c,onBroadcast:this.devtoolsConfig.enabled?()=>{this.devToolsHookCb&&this.devToolsHookCb()}:void 0,localState:l});this.prioritizeCacheValues=s||i>0;i&&setTimeout((()=>{this.prioritizeCacheValues=false}),i);this.devtoolsConfig.enabled&&this.connectToDevTools()}connectToDevTools(){if(typeof window==="undefined")return;const e=window;const t=Symbol.for("apollo.devtools");(e[t]=e[t]||[]).push(this);e.__APOLLO_CLIENT__=this;if(!Qe&&M){Qe=true;window.document&&window.top===window.self&&/^(https?|file):$/.test(window.location.protocol)&&setTimeout((()=>{if(!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__){const e=window.navigator;const t=e&&e.userAgent;let r;typeof t==="string"&&(t.indexOf("Chrome/")>-1?r="https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm":t.indexOf("Firefox/")>-1&&(r="https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/"));r&&M&&J.log("Download the Apollo DevTools for a better development experience: %s",r)}}),1e4)}}get documentTransform(){return this.queryManager.documentTransform}get localState(){return this.queryManager.localState}set localState(e){this.queryManager.localState=e}stop(){this.queryManager.stop()}watchQuery(e){this.defaultOptions.watchQuery&&(e=Y(this.defaultOptions.watchQuery,e));return this.queryManager.watchQuery(e)}
/**
     * This resolves a single query according to the options specified and
     * returns a `Promise` which is either resolved with the resulting data
     * or rejected with an error.
     *
     * @param options - An object of type `QueryOptions` that allows us to
     * describe how this query should be treated e.g. whether it should hit the
     * server at all or just resolve from the cache, etc.
     */query(e){this.defaultOptions.query&&(e=Y(this.defaultOptions.query,e));if(M){J(e.fetchPolicy!=="cache-and-network",67);J(e.fetchPolicy!=="standby",68);J(e.query,69);J(e.query.kind==="Document",70);J(!e.returnPartialData,71);J(!e.pollInterval,72);J(!e.notifyOnNetworkStatusChange,73)}return this.queryManager.query(e)}mutate(t){const r=Y(T({fetchPolicy:"network-only",errorPolicy:"none"},this.defaultOptions.mutate),t);if(M){J(r.mutation,74);J(r.fetchPolicy==="network-only"||r.fetchPolicy==="no-cache",75)}V(r.mutation,e.MUTATION);return this.queryManager.mutate(r)}subscribe(e){const t={};const r=this.queryManager.startGraphQLSubscription(e);const s=r.pipe(h((r=>({...r,data:this.queryManager.maskOperation({document:e.query,data:r.data,fetchPolicy:e.fetchPolicy,cause:t})}))));return Object.assign(s,{restart:r.restart})}readQuery(e,t=false){return this.cache.readQuery({...e,query:this.transform(e.query)},t)}
/**
     * Watches the cache store of the fragment according to the options specified
     * and returns an `Observable`. We can subscribe to this
     * `Observable` and receive updated results through an
     * observer when the cache store changes.
     *
     * You must pass in a GraphQL document with a single fragment or a document
     * with multiple fragments that represent what you are reading. If you pass
     * in a document with multiple fragments then you must also specify a
     * `fragmentName`.
     *
     * @since 3.10.0
     * @param options - An object of type `WatchFragmentOptions` that allows
     * the cache to identify the fragment and optionally specify whether to react
     * to optimistic updates.
     */watchFragment(e){const t=this.queryManager.dataMasking;return this.cache.watchFragment({...e,fragment:this.transform(e.fragment,t)}).pipe(h((r=>{if(M&&t){const t=this.queryManager.maskFragment({...e,data:r.data});return{...r,data:t}}return r})))}readFragment(e,t=false){return this.cache.readFragment({...e,fragment:this.transform(e.fragment)},t)}writeQuery(e){const t=this.cache.writeQuery(e);e.broadcast!==false&&this.queryManager.broadcastQueries();return t}writeFragment(e){const t=this.cache.writeFragment(e);e.broadcast!==false&&this.queryManager.broadcastQueries();return t}__actionHookForDevTools(e){this.devToolsHookCb=e}__requestRaw(e){return O(this.link,e,{client:this})}resetStore(){return Promise.resolve().then((()=>this.queryManager.clearStore({discardWatches:false}))).then((()=>Promise.all(this.resetStoreCallbacks.map((e=>e()))))).then((()=>this.refetchObservableQueries()))}clearStore(){return Promise.resolve().then((()=>this.queryManager.clearStore({discardWatches:true}))).then((()=>Promise.all(this.clearStoreCallbacks.map((e=>e())))))}onResetStore(e){this.resetStoreCallbacks.push(e);return()=>{this.resetStoreCallbacks=this.resetStoreCallbacks.filter((t=>t!==e))}}onClearStore(e){this.clearStoreCallbacks.push(e);return()=>{this.clearStoreCallbacks=this.clearStoreCallbacks.filter((t=>t!==e))}}
/**
     * Refetches all of your active queries.
     *
     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage
     *
     * It is important to remember that `reFetchObservableQueries()` _will_ refetch any active
     * queries. This means that any components that might be mounted will execute
     * their queries again using your network interface. If you do not want to
     * re-execute any queries then you should make sure to stop watching any
     * active queries.
     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.
     *
     * Note: `cache-only` queries are not refetched by this function.
     *
     * @deprecated Please use `refetchObservableQueries` instead.
     */reFetchObservableQueries;refetchObservableQueries(e){return this.queryManager.refetchObservableQueries(e)}refetchQueries(e){const t=this.queryManager.refetchQueries(e);const r=[];const s=[];t.forEach(((e,t)=>{r.push(t);s.push(e)}));const i=Promise.all(s);i.queries=r;i.results=s;i.catch((e=>{M&&J.debug(76,e)}));return i}getObservableQueries(e="active"){return this.queryManager.getObservableQueries(e)}
/**
     * Exposes the cache's complete state, in a serializable format for later restoration.
     *
     * @remarks
     *
     * This can be useful for debugging in order to inspect the full state of the
     * cache.
     *
     * @param optimistic - Determines whether the result contains data from the
     * optimistic layer
     */extract(e){return this.cache.extract(e)}restore(e){return this.cache.restore(e)}setLink(e){this.link=e}get defaultContext(){return this.queryManager.defaultContext}maskedFragmentTransform=new Q($);transform(e,t=false){const r=this.queryManager.transform(e);return t?this.maskedFragmentTransform.transformDocument(r):r}}M&&(ApolloClient.prototype.getMemoryInternals=K);export{ApolloClient,ue as NetworkStatus,ObservableQuery,Z as version};

