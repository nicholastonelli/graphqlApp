// path-scurry@1.11.1 downloaded from https://ga.jspm.io/npm:path-scurry@1.11.1/dist/commonjs/index.js

import*as t from"lru-cache";import*as e from"node:path";import*as i from"node:url";import*as s from"fs";import*as r from"node:fs";import*as a from"node:fs/promises";import*as n from"minipass";import h from"process";var o=t;try{"default"in t&&(o=t.default)}catch(t){}var l=e;try{"default"in e&&(l=e.default)}catch(t){}var c=i;try{"default"in i&&(c=i.default)}catch(t){}var d=s;try{"default"in s&&(d=s.default)}catch(t){}var u=r;try{"default"in r&&(u=r.default)}catch(t){}var p=a;try{"default"in a&&(p=a.default)}catch(t){}var f=n;try{"default"in n&&(f=n.default)}catch(t){}var y={};var w=h;var m=y&&y.__createBinding||(Object.create?function(t,e,i,s){s===void 0&&(s=i);var r=Object.getOwnPropertyDescriptor(e,i);r&&!("get"in r?!e.__esModule:r.writable||r.configurable)||(r={enumerable:true,get:function(){return e[i]}});Object.defineProperty(t,s,r)}:function(t,e,i,s){s===void 0&&(s=i);t[s]=e[i]});var P=y&&y.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:true,value:e})}:function(t,e){t.default=e});var v=y&&y.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(t!=null)for(var i in t)i!=="default"&&Object.prototype.hasOwnProperty.call(t,i)&&m(e,t,i);P(e,t);return e};Object.defineProperty(y,"__esModule",{value:true});y.PathScurry=y.Path=y.PathScurryDarwin=y.PathScurryPosix=y.PathScurryWin32=y.PathScurryBase=y.PathPosix=y.PathWin32=y.PathBase=y.ChildrenCache=y.ResolveCache=void 0;const S=o;const g=l;const k=c;const C=d;const R=v(u);const F=C.realpathSync.native;const b=p;const T=f;const x={lstatSync:C.lstatSync,readdir:C.readdir,readdirSync:C.readdirSync,readlinkSync:C.readlinkSync,realpathSync:F,promises:{lstat:b.lstat,readdir:b.readdir,readlink:b.readlink,realpath:b.realpath}};const fsFromOption=t=>t&&t!==x&&t!==R?{...x,...t,promises:{...x.promises,...t.promises||{}}}:x;const N=/^\\\\\?\\([a-z]:)\\?$/i;const uncToDrive=t=>t.replace(/\//g,"\\").replace(N,"$1\\");const B=/[\\\/]/;const E=0;const O=1;const M=2;const D=4;const W=6;const I=8;const A=10;const L=12;const z=15;const U=~z;const j=16;const _=32;const $=64;const H=128;const q=256;const K=512;const V=$|H|K;const G=1023;const entToType=t=>t.isFile()?I:t.isDirectory()?D:t.isSymbolicLink()?A:t.isCharacterDevice()?M:t.isBlockDevice()?W:t.isSocket()?L:t.isFIFO()?O:E;const J=new Map;const normalize=t=>{const e=J.get(t);if(e)return e;const i=t.normalize("NFKD");J.set(t,i);return i};const Q=new Map;const normalizeNocase=t=>{const e=Q.get(t);if(e)return e;const i=normalize(t.toLowerCase());Q.set(t,i);return i};class ResolveCache extends S.LRUCache{constructor(){super({max:256})}}y.ResolveCache=ResolveCache;class ChildrenCache extends S.LRUCache{constructor(t=16384){super({maxSize:t,sizeCalculation:t=>t.length+1})}}y.ChildrenCache=ChildrenCache;const X=Symbol("PathScurry setAsCwd");class PathBase{name;root;roots;parent;nocase;isCWD=false;#t;#e;get dev(){return this.#e}#i;get mode(){return this.#i}#s;get nlink(){return this.#s}#r;get uid(){return this.#r}#a;get gid(){return this.#a}#n;get rdev(){return this.#n}#h;get blksize(){return this.#h}#o;get ino(){return this.#o}#l;get size(){return this.#l}#c;get blocks(){return this.#c}#d;get atimeMs(){return this.#d}#u;get mtimeMs(){return this.#u}#p;get ctimeMs(){return this.#p}#f;get birthtimeMs(){return this.#f}#y;get atime(){return this.#y}#w;get mtime(){return this.#w}#m;get ctime(){return this.#m}#P;get birthtime(){return this.#P}#v;#S;#g;#k;#C;#R;#F;#b;#T;#x;get parentPath(){return(this.parent||this).fullpath()}get path(){return this.parentPath}constructor(t,e=E,i,s,r,a,n){this.name=t;this.#v=r?normalizeNocase(t):normalize(t);this.#F=e&G;this.nocase=r;this.roots=s;this.root=i||this;this.#b=a;this.#g=n.fullpath;this.#C=n.relative;this.#R=n.relativePosix;this.parent=n.parent;this.parent?this.#t=this.parent.#t:this.#t=fsFromOption(n.fs)}depth(){return this.#S!==void 0?this.#S:this.parent?this.#S=this.parent.depth()+1:this.#S=0}childrenCache(){return this.#b}resolve(t){if(!t)return this;const e=this.getRootString(t);const i=t.substring(e.length);const s=i.split(this.splitSep);const r=e?this.getRoot(e).#N(s):this.#N(s);return r}#N(t){let e=this;for(const i of t)e=e.child(i);return e}children(){const t=this.#b.get(this);if(t)return t;const e=Object.assign([],{provisional:0});this.#b.set(this,e);this.#F&=~j;return e}child(t,e){if(t===""||t===".")return this;if(t==="..")return this.parent||this;const i=this.children();const s=this.nocase?normalizeNocase(t):normalize(t);for(const t of i)if(t.#v===s)return t;const r=this.parent?this.sep:"";const a=this.#g?this.#g+r+t:void 0;const n=this.newChild(t,E,{...e,parent:this,fullpath:a});this.canReaddir()||(n.#F|=H);i.push(n);return n}relative(){if(this.isCWD)return"";if(this.#C!==void 0)return this.#C;const t=this.name;const e=this.parent;if(!e)return this.#C=this.name;const i=e.relative();return i+(i&&e.parent?this.sep:"")+t}relativePosix(){if(this.sep==="/")return this.relative();if(this.isCWD)return"";if(this.#R!==void 0)return this.#R;const t=this.name;const e=this.parent;if(!e)return this.#R=this.fullpathPosix();const i=e.relativePosix();return i+(i&&e.parent?"/":"")+t}fullpath(){if(this.#g!==void 0)return this.#g;const t=this.name;const e=this.parent;if(!e)return this.#g=this.name;const i=e.fullpath();const s=i+(e.parent?this.sep:"")+t;return this.#g=s}fullpathPosix(){if(this.#k!==void 0)return this.#k;if(this.sep==="/")return this.#k=this.fullpath();if(!this.parent){const t=this.fullpath().replace(/\\/g,"/");return/^[a-z]:\//i.test(t)?this.#k=`//?/${t}`:this.#k=t}const t=this.parent;const e=t.fullpathPosix();const i=e+(e&&t.parent?"/":"")+this.name;return this.#k=i}isUnknown(){return(this.#F&z)===E}isType(t){return this[`is${t}`]()}getType(){return this.isUnknown()?"Unknown":this.isDirectory()?"Directory":this.isFile()?"File":this.isSymbolicLink()?"SymbolicLink":this.isFIFO()?"FIFO":this.isCharacterDevice()?"CharacterDevice":this.isBlockDevice()?"BlockDevice":this.isSocket()?"Socket":"Unknown"}isFile(){return(this.#F&z)===I}isDirectory(){return(this.#F&z)===D}isCharacterDevice(){return(this.#F&z)===M}isBlockDevice(){return(this.#F&z)===W}isFIFO(){return(this.#F&z)===O}isSocket(){return(this.#F&z)===L}isSymbolicLink(){return(this.#F&A)===A}lstatCached(){return this.#F&_?this:void 0}readlinkCached(){return this.#T}realpathCached(){return this.#x}readdirCached(){const t=this.children();return t.slice(0,t.provisional)}canReadlink(){if(this.#T)return true;if(!this.parent)return false;const t=this.#F&z;return!(t!==E&&t!==A||this.#F&q||this.#F&H)}calledReaddir(){return!!(this.#F&j)}isENOENT(){return!!(this.#F&H)}isNamed(t){return this.nocase?this.#v===normalizeNocase(t):this.#v===normalize(t)}async readlink(){const t=this.#T;if(t)return t;if(this.canReadlink()&&this.parent)try{const t=await this.#t.promises.readlink(this.fullpath());const e=(await this.parent.realpath())?.resolve(t);if(e)return this.#T=e}catch(t){this.#B(t.code);return}}readlinkSync(){const t=this.#T;if(t)return t;if(this.canReadlink()&&this.parent)try{const t=this.#t.readlinkSync(this.fullpath());const e=this.parent.realpathSync()?.resolve(t);if(e)return this.#T=e}catch(t){this.#B(t.code);return}}#E(t){this.#F|=j;for(let e=t.provisional;e<t.length;e++){const i=t[e];i&&i.#O()}}#O(){if(!(this.#F&H)){this.#F=(this.#F|H)&U;this.#M()}}#M(){const t=this.children();t.provisional=0;for(const e of t)e.#O()}#D(){this.#F|=K;this.#W()}#W(){if(this.#F&$)return;let t=this.#F;(t&z)===D&&(t&=U);this.#F=t|$;this.#M()}#I(t=""){t==="ENOTDIR"||t==="EPERM"?this.#W():t==="ENOENT"?this.#O():this.children().provisional=0}#A(t=""){if(t==="ENOTDIR"){const t=this.parent;t.#W()}else t==="ENOENT"&&this.#O()}#B(t=""){let e=this.#F;e|=q;t==="ENOENT"&&(e|=H);t!=="EINVAL"&&t!=="UNKNOWN"||(e&=U);this.#F=e;t==="ENOTDIR"&&this.parent&&this.parent.#W()}#L(t,e){return this.#z(t,e)||this.#U(t,e)}#U(t,e){const i=entToType(t);const s=this.newChild(t.name,i,{parent:this});const r=s.#F&z;r!==D&&r!==A&&r!==E&&(s.#F|=$);e.unshift(s);e.provisional++;return s}#z(t,e){for(let i=e.provisional;i<e.length;i++){const s=e[i];const r=this.nocase?normalizeNocase(t.name):normalize(t.name);if(r===s.#v)return this.#j(t,s,i,e)}}#j(t,e,i,s){const r=e.name;e.#F=e.#F&U|entToType(t);r!==t.name&&(e.name=t.name);if(i!==s.provisional){i===s.length-1?s.pop():s.splice(i,1);s.unshift(e)}s.provisional++;return e}async lstat(){if((this.#F&H)===0)try{this.#_(await this.#t.promises.lstat(this.fullpath()));return this}catch(t){this.#A(t.code)}}lstatSync(){if((this.#F&H)===0)try{this.#_(this.#t.lstatSync(this.fullpath()));return this}catch(t){this.#A(t.code)}}#_(t){const{atime:e,atimeMs:i,birthtime:s,birthtimeMs:r,blksize:a,blocks:n,ctime:h,ctimeMs:o,dev:l,gid:c,ino:d,mode:u,mtime:p,mtimeMs:f,nlink:y,rdev:w,size:m,uid:P}=t;this.#y=e;this.#d=i;this.#P=s;this.#f=r;this.#h=a;this.#c=n;this.#m=h;this.#p=o;this.#e=l;this.#a=c;this.#o=d;this.#i=u;this.#w=p;this.#u=f;this.#s=y;this.#n=w;this.#l=m;this.#r=P;const v=entToType(t);this.#F=this.#F&U|v|_;v!==E&&v!==D&&v!==A&&(this.#F|=$)}#$=[];#H=false;#q(t){this.#H=false;const e=this.#$.slice();this.#$.length=0;e.forEach((e=>e(null,t)))}
/**
   * Standard node-style callback interface to get list of directory entries.
   *
   * If the Path cannot or does not contain any children, then an empty array
   * is returned.
   *
   * Results are cached, and thus may be out of date if the filesystem is
   * mutated.
   *
   * @param cb The callback called with (er, entries).  Note that the `er`
   * param is somewhat extraneous, as all readdir() errors are handled and
   * simply result in an empty set of entries being returned.
   * @param allowZalgo Boolean indicating that immediately known results should
   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
   * zalgo at your peril, the dark pony lord is devious and unforgiving.
   */readdirCB(t,e=false){if(!this.canReaddir()){e?t(null,[]):queueMicrotask((()=>t(null,[])));return}const i=this.children();if(this.calledReaddir()){const s=i.slice(0,i.provisional);e?t(null,s):queueMicrotask((()=>t(null,s)));return}this.#$.push(t);if(this.#H)return;this.#H=true;const s=this.fullpath();this.#t.readdir(s,{withFileTypes:true},((t,e)=>{if(t){this.#I(t.code);i.provisional=0}else{for(const t of e)this.#L(t,i);this.#E(i)}this.#q(i.slice(0,i.provisional))}))}#K;async readdir(){if(!this.canReaddir())return[];const t=this.children();if(this.calledReaddir())return t.slice(0,t.provisional);const e=this.fullpath();if(this.#K)await this.#K;else{let resolve=()=>{};this.#K=new Promise((t=>resolve=t));try{for(const i of await this.#t.promises.readdir(e,{withFileTypes:true}))this.#L(i,t);this.#E(t)}catch(e){this.#I(e.code);t.provisional=0}this.#K=void 0;resolve()}return t.slice(0,t.provisional)}readdirSync(){if(!this.canReaddir())return[];const t=this.children();if(this.calledReaddir())return t.slice(0,t.provisional);const e=this.fullpath();try{for(const i of this.#t.readdirSync(e,{withFileTypes:true}))this.#L(i,t);this.#E(t)}catch(e){this.#I(e.code);t.provisional=0}return t.slice(0,t.provisional)}canReaddir(){if(this.#F&V)return false;const t=z&this.#F;return t===E||t===D||t===A}shouldWalk(t,e){return(this.#F&D)===D&&!(this.#F&V)&&!t.has(this)&&(!e||e(this))}async realpath(){if(this.#x)return this.#x;if(!((K|q|H)&this.#F))try{const t=await this.#t.promises.realpath(this.fullpath());return this.#x=this.resolve(t)}catch(t){this.#D()}}realpathSync(){if(this.#x)return this.#x;if(!((K|q|H)&this.#F))try{const t=this.#t.realpathSync(this.fullpath());return this.#x=this.resolve(t)}catch(t){this.#D()}}[X](t){if(t===this)return;t.isCWD=false;this.isCWD=true;const e=new Set([]);let i=[];let s=this;while(s&&s.parent){e.add(s);s.#C=i.join(this.sep);s.#R=i.join("/");s=s.parent;i.push("..")}s=t;while(s&&s.parent&&!e.has(s)){s.#C=void 0;s.#R=void 0;s=s.parent}}}y.PathBase=PathBase;class PathWin32 extends PathBase{sep="\\";splitSep=B;constructor(t,e=E,i,s,r,a,n){super(t,e,i,s,r,a,n)}newChild(t,e=E,i={}){return new PathWin32(t,e,this.root,this.roots,this.nocase,this.childrenCache(),i)}getRootString(t){return g.win32.parse(t).root}getRoot(t){t=uncToDrive(t.toUpperCase());if(t===this.root.name)return this.root;for(const[e,i]of Object.entries(this.roots))if(this.sameRoot(t,e))return this.roots[t]=i;return this.roots[t]=new PathScurryWin32(t,this).root}sameRoot(t,e=this.root.name){t=t.toUpperCase().replace(/\//g,"\\").replace(N,"$1\\");return t===e}}y.PathWin32=PathWin32;class PathPosix extends PathBase{splitSep="/";sep="/";constructor(t,e=E,i,s,r,a,n){super(t,e,i,s,r,a,n)}getRootString(t){return t.startsWith("/")?"/":""}getRoot(t){return this.root}newChild(t,e=E,i={}){return new PathPosix(t,e,this.root,this.roots,this.nocase,this.childrenCache(),i)}}y.PathPosix=PathPosix;class PathScurryBase{root;rootPath;roots;cwd;#V;#G;#b;nocase;#t;constructor(t=w.cwd(),e,i,{nocase:s,childrenCacheSize:r=16384,fs:a=x}={}){this.#t=fsFromOption(a);(t instanceof URL||t.startsWith("file://"))&&(t=(0,k.fileURLToPath)(t));const n=e.resolve(t);this.roots=Object.create(null);this.rootPath=this.parseRootPath(n);this.#V=new ResolveCache;this.#G=new ResolveCache;this.#b=new ChildrenCache(r);const h=n.substring(this.rootPath.length).split(i);h.length!==1||h[0]||h.pop();if(s===void 0)throw new TypeError("must provide nocase setting to PathScurryBase ctor");this.nocase=s;this.root=this.newRoot(this.#t);this.roots[this.rootPath]=this.root;let o=this.root;let l=h.length-1;const c=e.sep;let d=this.rootPath;let u=false;for(const t of h){const e=l--;o=o.child(t,{relative:new Array(e).fill("..").join(c),relativePosix:new Array(e).fill("..").join("/"),fullpath:d+=(u?"":c)+t});u=true}this.cwd=o}depth(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return t.depth()}childrenCache(){return this.#b}resolve(...t){let e="";for(let i=t.length-1;i>=0;i--){const s=t[i];if(s&&s!=="."){e=e?`${s}/${e}`:s;if(this.isAbsolute(s))break}}const i=this.#V.get(e);if(i!==void 0)return i;const s=this.cwd.resolve(e).fullpath();this.#V.set(e,s);return s}resolvePosix(...t){let e="";for(let i=t.length-1;i>=0;i--){const s=t[i];if(s&&s!=="."){e=e?`${s}/${e}`:s;if(this.isAbsolute(s))break}}const i=this.#G.get(e);if(i!==void 0)return i;const s=this.cwd.resolve(e).fullpathPosix();this.#G.set(e,s);return s}relative(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return t.relative()}relativePosix(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return t.relativePosix()}basename(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return t.name}dirname(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return(t.parent||t).fullpath()}async readdir(t=this.cwd,e={withFileTypes:true}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i}=e;if(t.canReaddir()){const e=await t.readdir();return i?e:e.map((t=>t.name))}return[]}readdirSync(t=this.cwd,e={withFileTypes:true}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i=true}=e;return t.canReaddir()?i?t.readdirSync():t.readdirSync().map((t=>t.name)):[]}async lstat(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return t.lstat()}lstatSync(t=this.cwd){typeof t==="string"&&(t=this.cwd.resolve(t));return t.lstatSync()}async readlink(t=this.cwd,{withFileTypes:e}={withFileTypes:false}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t.withFileTypes;t=this.cwd}const i=await t.readlink();return e?i:i?.fullpath()}readlinkSync(t=this.cwd,{withFileTypes:e}={withFileTypes:false}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t.withFileTypes;t=this.cwd}const i=t.readlinkSync();return e?i:i?.fullpath()}async realpath(t=this.cwd,{withFileTypes:e}={withFileTypes:false}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t.withFileTypes;t=this.cwd}const i=await t.realpath();return e?i:i?.fullpath()}realpathSync(t=this.cwd,{withFileTypes:e}={withFileTypes:false}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t.withFileTypes;t=this.cwd}const i=t.realpathSync();return e?i:i?.fullpath()}async walk(t=this.cwd,e={}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i=true,follow:s=false,filter:r,walkFilter:a}=e;const n=[];r&&!r(t)||n.push(i?t:t.fullpath());const h=new Set;const walk=(t,e)=>{h.add(t);t.readdirCB(((t,o)=>{if(t)return e(t);let l=o.length;if(!l)return e();const next=()=>{--l===0&&e()};for(const t of o){r&&!r(t)||n.push(i?t:t.fullpath());s&&t.isSymbolicLink()?t.realpath().then((t=>t?.isUnknown()?t.lstat():t)).then((t=>t?.shouldWalk(h,a)?walk(t,next):next())):t.shouldWalk(h,a)?walk(t,next):next()}}),true)};const o=t;return new Promise(((t,e)=>{walk(o,(i=>{if(i)return e(i);t(n)}))}))}walkSync(t=this.cwd,e={}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i=true,follow:s=false,filter:r,walkFilter:a}=e;const n=[];r&&!r(t)||n.push(i?t:t.fullpath());const h=new Set([t]);for(const t of h){const e=t.readdirSync();for(const t of e){r&&!r(t)||n.push(i?t:t.fullpath());let e=t;if(t.isSymbolicLink()){if(!(s&&(e=t.realpathSync())))continue;e.isUnknown()&&e.lstatSync()}e.shouldWalk(h,a)&&h.add(e)}}return n}[Symbol.asyncIterator](){return this.iterate()}iterate(t=this.cwd,e={}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}return this.stream(t,e)[Symbol.asyncIterator]()}[Symbol.iterator](){return this.iterateSync()}*iterateSync(t=this.cwd,e={}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i=true,follow:s=false,filter:r,walkFilter:a}=e;r&&!r(t)||(yield i?t:t.fullpath());const n=new Set([t]);for(const t of n){const e=t.readdirSync();for(const t of e){r&&!r(t)||(yield i?t:t.fullpath());let e=t;if(t.isSymbolicLink()){if(!(s&&(e=t.realpathSync())))continue;e.isUnknown()&&e.lstatSync()}e.shouldWalk(n,a)&&n.add(e)}}}stream(t=this.cwd,e={}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i=true,follow:s=false,filter:r,walkFilter:a}=e;const n=new T.Minipass({objectMode:true});r&&!r(t)||n.write(i?t:t.fullpath());const h=new Set;const o=[t];let l=0;const process=()=>{let t=false;while(!t){const e=o.shift();if(!e){l===0&&n.end();return}l++;h.add(e);const onReaddir=(e,d,u=false)=>{if(e)return n.emit("error",e);if(s&&!u){const t=[];for(const e of d)e.isSymbolicLink()&&t.push(e.realpath().then((t=>t?.isUnknown()?t.lstat():t)));if(t.length){Promise.all(t).then((()=>onReaddir(null,d,true)));return}}for(const e of d)!e||r&&!r(e)||n.write(i?e:e.fullpath())||(t=true);l--;for(const t of d){const e=t.realpathCached()||t;e.shouldWalk(h,a)&&o.push(e)}t&&!n.flowing?n.once("drain",process):c||process()};let c=true;e.readdirCB(onReaddir,true);c=false}};process();return n}streamSync(t=this.cwd,e={}){if(typeof t==="string")t=this.cwd.resolve(t);else if(!(t instanceof PathBase)){e=t;t=this.cwd}const{withFileTypes:i=true,follow:s=false,filter:r,walkFilter:a}=e;const n=new T.Minipass({objectMode:true});const h=new Set;r&&!r(t)||n.write(i?t:t.fullpath());const o=[t];let l=0;const process=()=>{let t=false;while(!t){const e=o.shift();if(!e){l===0&&n.end();return}l++;h.add(e);const c=e.readdirSync();for(const e of c)r&&!r(e)||n.write(i?e:e.fullpath())||(t=true);l--;for(const t of c){let e=t;if(t.isSymbolicLink()){if(!(s&&(e=t.realpathSync())))continue;e.isUnknown()&&e.lstatSync()}e.shouldWalk(h,a)&&o.push(e)}}t&&!n.flowing&&n.once("drain",process)};process();return n}chdir(t=this.cwd){const e=this.cwd;this.cwd=typeof t==="string"?this.cwd.resolve(t):t;this.cwd[X](e)}}y.PathScurryBase=PathScurryBase;class PathScurryWin32 extends PathScurryBase{sep="\\";constructor(t=w.cwd(),e={}){const{nocase:i=true}=e;super(t,g.win32,"\\",{...e,nocase:i});this.nocase=i;for(let t=this.cwd;t;t=t.parent)t.nocase=this.nocase}parseRootPath(t){return g.win32.parse(t).root.toUpperCase()}newRoot(t){return new PathWin32(this.rootPath,D,void 0,this.roots,this.nocase,this.childrenCache(),{fs:t})}isAbsolute(t){return t.startsWith("/")||t.startsWith("\\")||/^[a-z]:(\/|\\)/i.test(t)}}y.PathScurryWin32=PathScurryWin32;class PathScurryPosix extends PathScurryBase{sep="/";constructor(t=w.cwd(),e={}){const{nocase:i=false}=e;super(t,g.posix,"/",{...e,nocase:i});this.nocase=i}parseRootPath(t){return"/"}newRoot(t){return new PathPosix(this.rootPath,D,void 0,this.roots,this.nocase,this.childrenCache(),{fs:t})}isAbsolute(t){return t.startsWith("/")}}y.PathScurryPosix=PathScurryPosix;class PathScurryDarwin extends PathScurryPosix{constructor(t=w.cwd(),e={}){const{nocase:i=true}=e;super(t,{...e,nocase:i})}}y.PathScurryDarwin=PathScurryDarwin;y.Path=w.platform==="win32"?PathWin32:PathPosix;y.PathScurry=w.platform==="win32"?PathScurryWin32:w.platform==="darwin"?PathScurryDarwin:PathScurryPosix;const Y=y.__esModule,Z=y.PathScurry,tt=y.Path;const et=y.PathScurryDarwin,it=y.PathScurryPosix,st=y.PathScurryWin32,rt=y.PathScurryBase,at=y.PathPosix,nt=y.PathWin32,ht=y.PathBase,ot=y.ChildrenCache,lt=y.ResolveCache;export{ot as ChildrenCache,tt as Path,ht as PathBase,at as PathPosix,Z as PathScurry,rt as PathScurryBase,et as PathScurryDarwin,it as PathScurryPosix,st as PathScurryWin32,nt as PathWin32,lt as ResolveCache,Y as __esModule,y as default};

